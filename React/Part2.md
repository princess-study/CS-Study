## 23. HTML과 React의 이벤트 처리 차이점에 대해 설명해주세요.

### 문법의 차이

HTML은 전달할 함수를 문자열의 형태로 전달하지만, React는 함수 그 자체로 핸들러를 전달합니다.

또한 HTML은 이벤트를 소문자로 갖지만, React는 camelCase를 사용함 (ex. onClick)

다른 차이점으로는, HTML에서 `false`를 반환하는 식으로 이벤트의 기본동작을 방지하지만, React에서는 `preventDefault`를 명시적으로 호출하여 이벤트의 기본동작을 막는다.

> **이벤트 핸들러 전달 방식:**
> 
> - **HTML:**
>     - 이벤트 핸들러를 문자열 형태로 속성에 직접 지정합니다.
>     - 예시: `<button onclick="myFunction()">Click me</button>`
> - **React:**
>     - 이벤트 핸들러를 함수 그 자체로 전달합니다.
>     - 예시: `<button onClick={myFunction}>Click me</button>`
> 
> **이벤트 기본 동작 방지:**
> 
> - **HTML:**
>     - `false`를 반환하여 이벤트 기본 동작을 방지합니다.
>     - 예시: `<button onclick="return false;">Click me</button>`
> - **React:**
>     - `preventDefault` method를 사용하여 이벤트 기본 동작을 명시적으로 방지해야 합니다.

## 24. Key Props를 사용하는 이유에 대해 설명해주세요.

`key`는 React가 어떤 항목을 변경, 추가 또는 삭제할지 식별하는 것을 돕습니다.

`key`는 엘리먼트에 안정적인 고유성을 부여하기 위해 배열 내부의 엘리먼트에 지정해야 합니다.

[**Key Props 사용 이유**](https://www.notion.so/Key-Props-507b5c5cb4a842eeb657bf4fb63d75a3?pvs=21)

## 25. Ref의 용도에 대해 설명해주세요.

컴포넌트가 특정 정보를 기억하도록 하고 싶지만, 해당 정보가 새 렌더링을 촉발하지 않도록 하려는 경우 ref를 사용할 수 있습니다.

### Ref 사용 이유

- **컴포넌트가 특정 정보를 기억해야 하는 경우:**
    - 예를 들어, 입력 필드의 값을 기억하거나 스크롤 위치를 기억해야 하는 경우 ref를 사용할 수 있습니다.
- **외부 시스템이나 브라우저 API를 사용해야 하는 경우:**
    - 예를 들어, `focus()` 메서드를 사용하여 입력 필드에 포커스를 맞추거나 `setInterval()` 함수를 사용하여 타이머를 설정해야 하는 경우 ref를 사용할 수 있습니다.
- **DOM 요소에 직접 접근해야 하는 경우:**
    - 예를 들어, DOM 요소의 크기 또는 위치를 가져오거나 DOM 요소에 스타일을 적용해야 하는 경우 ref를 사용할 수 있습니다.

### **Ref의 주요 장점**

- **성능 향상:**
    - Ref는 렌더링을 트리거하지 않기 때문에 컴포넌트 성능을 향상시킬 수 있습니다.
- **코드의 간결성:**
    - Ref는 코드를 더 간결하고 이해하기 쉽게 만들 수 있습니다.
- **유연성:**
    - Ref는 다양한 상황에서 사용할 수 있는 매우 유연한 도구입니다.

### **Ref 사용 시 주의 사항**

- **Ref는 컴포넌트 인스턴스에 직접 접근하기 때문에 주의해서 사용해야 합니다.**
- **Ref는 함수형 컴포넌트에서 사용할 때 주의해야 합니다.**
- **Ref는 최신 버전의 React에서만 사용할 수 있습니다.**

## 27. HOC (Higher-Order Components)에 대해 설명해주세요.

고차 컴포넌트는 컴포넌트를 인자로 받아 새로운 컴포넌트를 다시 return해주는 함수입니다.

## 28. Context API에 대해 설명해주세요.

Context API는 React의 **의존성 주입 도구**입니다.

Context는 React 컴포넌트 트리 안에서 전역적이라고 볼 수 있는 데이터를 공유할 수 있도록 고안된 방법으로, 예를 들어, 로그인 유저, 테마, 언어 등이 있습니다.

## 29. React.Fragment에 대해 설명해주세요.

리액트 컴포넌트는 1개의 엘리먼트를 리턴해야 하며, 여러개의 엘리먼트를 리턴할 경우, 에러가 발생합니다.

이러한 상황처럼, 여러개의 엘리먼트를 단일 엘리먼트가 들어갈 수 있는 위치에 배치하고자 할때, 사용할 수 있는 문법으로, `Fragment`는 엘리먼트들을 다른 컨테이너로 감싸지 않기 때문에 레이아웃이나 스타일에 영향을 주지 않습니다.

```jsx
const MyComponent = () => {
  return (
    <React.Fragment>
      <li>Item 1</li>
      <li>Item 2</li>
      <li>Item 3</li>
    </React.Fragment>
  );
};

/// <React.Fragment></React.Fragment>a === <></>
```

| 특징 | Fragment | div |
| --- | --- | --- |
| DOM 요소 생성 | 생성하지 않음 | 생성함 |
| 레이아웃 영향 | 영향을 주지 않음 | 영향을 줄 수 있음 |
| 성능 | 더 나은 성능 | 성능 저하 가능성 |

**결론**

Fragment는 여러 개의 엘리먼트를 단일 엘리먼트처럼 묶어 리턴해야 하는 경우 유용한 도구입니다. Fragment는 코드 간결성, 가독성, 성능 등의 장점을 가지고 있으며, `div` 보다 더 효율적인 솔루션입니다.

## 30. Portal에 대해 설명해주세요.

`Portal`을 사용하면, 컴포넌트가 일부 자식 컴포넌트를 DOM의 다른 위치로 렌더링할 수 있습니다.

`Portal`은 오로지 DOM 노드의 **물리적 배치만 변경**하며, 다른 모든 면에서는 이를 렌더링하는 `React` 컴포넌트의 자식 노드 역할을 합니다.

예를 들어, 자식은 부모 컴포넌트의 컨텍스트에 접근할 수 있으며, 이벤트는 자식에서 부모로 버블링됩니다.

[**Portal이란 무엇인가?**](https://www.notion.so/Portal-d787d62aa4f24ce99f2cc57f68046b9e?pvs=21)

## 31. 에러 바운더리에 대해 설명해주세요.

에러 바운더리는 하위 컴포넌트에서 발생하는 에러를 잡아서 선언적으로 처리할 수 있는 컴포넌트입니다.

이는 try-catch와 비슷한 형식으로, `getDerivedStateFromError`를 사용하면 폴백 UI를 렌더링할 수 있고, `componentDidCatch`를 사용하면 에러 정보를 기록할 수 있습니다.

[**에러 바운더리란 무엇인가?**](https://www.notion.so/06c6777ada63485ead07785ea33e5742?pvs=21)

## 32. 메모이제이션에 대해 설명해주세요.

메모이제이션이란 계산된 값을 자료구조에 저장하고 이 후 같은 계산을 반복하지 않고 자료구조에서 꺼내 재사용하는 것을 말합니다.

메모이제이션의 대표적인 예로는 동적계획법의 탑다운 방식이 있습니다.

[**메모이제이션이란 무엇인가?**](https://www.notion.so/cade9c85dd934d5f979643d322a5c603?pvs=21)

## 33. 리액트에서 메모이제이션을 어떤 방식으로 활용할 수 있나요?

리액트는 값을 메모이제이션하기 위한 `useMemo`와 함수를 메모이제이션하기 위한 `useCallback`을 사용하여 메모이제이션을 사용할 수 있습니다.

이 둘을 활용하면 퍼포먼스 최적화를 할 수 있습니다.

## 34. useMemo와 useCallback에 대해 설명해주세요.

`useMemo`는 deps 배열의 요소가 변경되지 않는 이상 함수의 반환값을 새로 계산하지 않기 위하여 사용합니다.

`useCallback`은 deps 배열의 요소가 변경되지 않는 이상, 함수를 새로 생성하지 않기 위하여 사용합니다. 대표적으로, 자식 컴포넌트에 함수를 넘겨줄 때 사용합니다.

## 35. React.memo와 useMemo의 차이에 대해 설명해주세요.

React.memo는 HOC이고, useMemo는 훅입니다.

React.memo는 컴포넌트 자체를 메모이제이션하는 용도로 사용하고, useMemo는 복잡한 계산의 결과 값을 메모이제이션하는 용도로 사용합니다. 물론 컴포넌트도 넣을 수는 있습니다.

[**React.memo와 useMemo의 차이점**](https://www.notion.so/React-memo-useMemo-de1be8dc48304952b38ed42a30ce9c05?pvs=21)

## 36. 리액트의 렌더링 성능 향상을 위해 어떻게 해야 하나요?

1. state와 props의 변경을 최소화합니다.

컴포넌트를 map을 통해 매핑할 때, key값으로 index를 사용하지 않는 등의 방법이 있습니다.

1. state와 props 변경에 의한 불필요한 하위 컴포넌트의 리렌더링을 최소화합니다.

`React.Memo`, `useMemo`, `useCallback` 등을 사용합니다.

## 37. React 18 버전 업데이트 내용에 대해 말씀해주세요.

1. **Automatic batching**
    
    React 18부터 상태 업데이트를 하나로 통합해서 배치처리한 뒤, 리렌더링을 진행합니다.
    
    > 웃프게도, 배치처리한ㅎㅜ 라고 썼다가 스팸처리가 되었었다.
    > 
2. **hydration error**
    
    텍스트 내용 누락, 불일치 등을 이제 경고가 아닌 오류로 처리합니다.
    
    리액트는 서버 마크업을 일치시키기 위해 클라이언트 노드에 삽입이나 삭제를 함으로서 개별 노드를 수정해주지 않고, 트리에서 가장 가까운 `<Suspense>` 바운더리까지 클라이언트 렌더링으로 돌아갑니다.
    
3. **Suspense**
    
    트리에 완전히 추가되기 전에 컴포넌트가 suspend된경우 리액트는 새 트리를 완전히 버리고, 비동기 작업이 완료될 때까지 기다린 다음, 다시 처음부터 렌더링을 시도합니다.
    
4. **새로운 js 환경**
    
    이제 모던 브라우저 기능인 `Promise`, `Symbol`, `Object.assign`에 의존합니다. 따라서 인터넷 익스플로러 등 오래된 브라우저를 지원해야 하는 경우 글로벌 폴리필을 추가하는 것을 고려해야 합니다.
    

## 38. Client Side Routing에 대해 설명해주세요.

CSR은 렌더링이 클라이언트 단에서 일어나는 방식으로, 서버가 클라이언트에 HTML과 JS를 보내고, 클라이언트는 이를 받아 렌더링을 시작합니다.

일반적으로 다음과 같은 순서로 진행됩니다.

1. User가 웹사이트 요청을 보냅니다.
2. CDN이 HTML파일과 JS로 접근할 수 있는 링크를 클라이언트로 보냅니다.
3. 클라이언트는 HTML과 JS를 다운로드 받습니다.
4. 다운로드된 JS를 실행하고, 데이터를 위한 API가 호출됩니다.
5. 서버가 API로부터의 요청에 응답합니다.
6. API로부터 받아온 데이터를 넣어줍니다. 이제 페이지가 상호작용해집니다.

## 39. 기억나는 Hook에 대해 전부 설명해주세요.

- useState
- useEffect
- useLayoutEffect
- useRef
- useMemo
- useCallback
- useReducer
- useEvent
- useImperativeHandle
- useSyncExternalStore
- useTransition

## 40. Redux에 대해 설명해주세요.

Redux는 자바스크립트 상태관리 라이브러리입니다.

## 41. Redux를 사용하는 이유에 대해 설명해주세요.

Redux는 모든 상태의 업데이트를 액션으로 정의하고, 액션 정보에 기반하여 리듀서에서 상태를 업데이트하기 때문에, 상태를 더욱 쉽게 예측가능하게 하여 유지보수 측면에 긍정적인 효과가 있습니다.

또한 Redux-saga, Redux-thunk와 같은 미들웨어를 통해 비동기작업에 대해 더 디테일하고 편한 컨트롤을 할 수 있게 됩니다.

## 42. Redux의 장단점에 대해 설명해주세요.

**단점**

가장 큰 단점은 어렵습니다. 리덕스의 기본 개념 자체를 이해하기 어렵습니다.

그리고, 리덕스를 유용하게 사용하려면 많은 패키지를 추가해야 합니다. 또한 리덕스 스토어 환경설정도 복잡하며, 보일러플레이트 코드를 너무 많이 요구합니다.

이는 **Redux-toolkit**을 사용하면, 어느정도 해결되는 문제입니다.

**장점**

리덕스를 잘 쓸 수 있게 되는 것의 가장 큰 장점은 상태관리가 쉽다는 것입니다.

프로젝트의 크기가 커지면, 상태가 굉장히 많고 다양해집니다.

그러나 Redux를 사용하면, 웹사이트의 상태를 어디서 관리해야 할지 고민하지 않아도 됩니다.

그리고, 어떤 액션을 통해 어떤 데이터가 변경되었는지 쉽게 알 수 있기 때문에, 상태를 좀 더 예측하기 쉽습니다.

## **보일러플레이트 코드란 무엇인가?**

**보일러플레이트 코드**는 프로그래밍에서 반복적으로 사용되는 코드 조각을 의미합니다. 이는 프로젝트 초기 설정, 라이브러리 또는 프레임워크 사용법, 파일 및 폴더 구조 등 일반적인 작업을 포함합니다.

## **리덕스 보일러플레이트 코드를 줄이는 방법:**

- **Redux Toolkit:**
    - Redux Toolkit은 리덕스 설정 및 사용을 간소화하는 도구입니다.
- **리액트 훅:**
    - useSelector, useDispatch와 같은 리액트 훅을 사용하여 컴포넌트에서 리덕스 스토어와 상호 작용할 수 있습니다.
- **템플릿 및 라이브러리:**
    - 리덕스 애플리케이션을 위한 다양한 템플릿 및 라이브러리가 존재합니다.

[**리덕스 보일러플레이트 코드 예시**](https://www.notion.so/5d5b6dcd6a15432f9d8a6c4d462bd4d3?pvs=21)

## 43. Flux 패턴에 대해 설명해주세요.

Flux 패턴은 사용자 입력을 기반으로 Action을 만들고, Action을 Dispatcher에 전달하여, Store의 데이터를 변경한 뒤, View에 반영하는 단방향의 흐름으로 애플리케이션을 만드는 아키텍처입니다.

## 44. Context API와 Redux를 비교해주세요.

Context API는 상태관리 도구가 아닙니다.

Context API는 **prop drilling**을 해결하기 위해 나온 도구이고, Redux는 상태를 좀더 쉽게 관리하고자 나온 도구입니다.

즉, Context API와 Redux를 비교하는 것보다는 Context API와 `useState`, `useReducer`를 이용한 상태관리와 Redux를 비교하는 것이 옳습니다.

이 둘의 차이점은 다음과 같습니다.

Redux는 컴포넌트에 상태값을 종속시키지 않고 바깥에서 관리할 수 있습니다.

또한 Redux는 리렌더링을 최적화합니다. useReducer와 달리, Redux를 사용하면 특정 값이 변경될 때에만 re-render할 수 있습니다. 이를 통해 성능 향상을 꾀할 수 있습니다.

그리고, `useReducer`는 미들웨어가 없습니다.

## 45. Redux의 3대 원칙에 대해 설명해주세요.

- **single source of truth**: 앱 전체에서 상태 관리 저장소는 단일 저장소로 존재한다.
- **state is read-only**: 상태를 변경하는 방법은 action을 reducer에 전파하는 것이 유일하다.
- **changes are made with pure functions**: 상태 변경 로직을 정의하는 리듀서들은 순수함수로 작성되어야 한다.

## 참조

- https://velog.io/@dnr6054/fe-interview-React
- https://ko.legacy.reactjs.org/docs/getting-started.html