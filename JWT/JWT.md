# JWT

## JWT 란?

### **JSON WebToken**

정보를 JSON형식으로 안전하게 전달하기 위한 간결하고 자체 포함된(JWT 자체가 필요한 모든 정보를 포함하고 있는 self-contained) 토큰이다.

<details>
<summary>[https://jwt.io/introduction](https://jwt.io/introduction)</summary>
<div markdown="1">

“정보를 JSON형식으로 안전하게 전달하기 위한 간결하고 자체 포함된 방법을 정의하는 개방형 표준(누구나 사용할 수 있도록 공개된 규칙이나 명세)이다.” 

Q. JWT 는 토큰아닌가? 왜 개방형 표준이라는 표현을 쓰죠? <br/><br/>
JWT는 실제로 '토큰' 형태로 사용되는 데이터 객체입니다. 하지만, 표준이라고 하는 이유는 JWT 자체가 단순히 데이터 형식이나 토큰만을 의미하는 것이 아니라, 
    그 데이터 형식과 토큰을 생성, 전달, 검증하기 위한 규칙과 구조를 정의하는 개방형 표준(RFC 7519)에 근거하기 때문입니다. [https://datatracker.ietf.org/doc/html/rfc7519](https://datatracker.ietf.org/doc/html/rfc7519)
    <br/>즉, JWT는 정보를 안전하게 전달하기 위한 구체적인 방법론과 알고리즘을 포함하는 광범위한 표준을 의미하며, 이 표준에 따라 생성된 구체적인 인스턴스, 
    즉 '토큰'을 우리는 실제로 사용하게 됩니다. 그러므로, JWT를 단순한 토큰이 아닌, 정보를 처리하는 방법을 규정한 '표준'으로 보는 것이 더 정확한 표현입니다. 
    다만,  기술적인 세부 사항보다는 JWT의 사용과 목적에 초점을 맞추는 경우가 많으므로, JWT를 간단히 "토큰"으로 언급하는 것이 더 적절하거나 이해하기 쉬울 수 있습니다.

</div>
</details>
    
    
    

### 인증과 인가의 차이

- **인증(Authentication)**: 사용자가 누구인지 확인하는 과정. 신원확인 예) 로그인과정
- **인가(Authorization)**: 인증된 사용자가 어떤 권한 이 있는지 결정/확인 과정.
    - JWT 사용자가 처음 시스템에 로그인(인증)할 때 생성되고 발급된다. 그러나 그 주된 사용 사례는 이후의 요청에서 사용자가 특정 자원에 접근하려 할 때, 그 사용자의 권한을 빠르게 확인(인가)하기 위함이다. 때문에 인가와 더 관련이 깊다고 볼 수 있다.

### 왜 도입되었는가?

기본 인증 웹은 비상태성(stateless) 프로토콜인 HTTP를 사용⇒ 이는 서버가 클라이언트의 이전 요청들을 기억하지 않는다는 것을 의미.⇒ 인증 상태를 알 길이 없다 ⇒ 즉, 사용자가 로그인한 후 다음 웹 페이지를 요청할 때마다 로그인 상태를 유지할 방법이 필요. (매번 로그인하면 사용자 경험이 너무 떨어짐)

1. ID와 비밀번호를 그대로 요청마다 전송: 보안에 취약 
2.  요청시마다 데이터베이스에 매번 접근해 해시값 대조: 리소스를 많이 소모하고, 처리 시간이 길어진다.

## Session vs JWT

### 세션 기반 인가 (전통적)

사용자의 인증 정보가  서버에 저장되는 방식. 

세션이 저장되는 곳은 메모리, 하드디스크, 또는 데이터베이스에 위치한다. (세션 기반 인가를 검색하면 나오는 “세션 저장소” 는 이를 뜻한다)

![session-based-authentication](https://github.com/princess-study/CS-Study/assets/92621272/620defbe-9e55-4e29-8f2f-5c65a9c78c72)
Session-based-authentication[^session]



1. **로그인**: 사용자의 로그인 시도.  일반적으로 아이디(ID)와 비밀번호를 입력한다.
2. **인증**: 시스템은 사용자가 제공한 자격 증명을 확인한다. 이는 일반적으로 데이터베이스나 다른 인증 저장소에 저장된 사용자 정보와 비교하여 이루어진다. 제공된 자격 증명이 올바르면 사용자는 인증된다. 
3. **세션 생성**: 사용자가 성공적으로 인증되면, 시스템은 사용자를 위한 새로운 세션을 생성한다. 이 세션에는 사용자의 고유 식별자(ID) 및 기타 필요한 정보가 포함될 수 있다. 이 세션 정보는 서버 측에 저장된다.
4. **세션 식별자 제공**: 사용자가 성공적으로 로그인하면, 시스템은 세션 식별자(Session ID)를 생성하고 브라우저의 쿠키(Cookie)등에 저장한다.
5. **세션 유지 및 활용**: 사용자가 시스템을 계속 사용하는 동안, 세션은 유지되며 사용자의 활동을 추적하고 관리한다. 이 세션을 통해 시스템은 사용자가 인증된 상태로 다양한 페이지나 서비스에 접근할 수 있도록 한다.(인가)
6. **세션 만료 및 로그아웃**: 사용자가 로그아웃하거나 세션이 만료될 때까지 세션은 유지된다. 사용자가 로그아웃하면, 세션은 종료되고 시스템은 해당 사용자의 접근 권한을 해제한다. 또한, 세션에는 만료 시간이 설정되어 있어 일정 시간 동안 활동이 없는 경우 자동으로 만료될 수 있다.

**⇒ 세션이란?** 세션 ID를 통해 서버에 사용자가 로그인 되어 있음을 지속적으로 유지하는 상태이다.

**단점**:

- 서버 부담 증가
    1. **서버 리소스 사용**: 세션은 서버 측에 저장되고 관리되므로, 많은 사용자가 동시에 로그인하고 활동을 유지할 때 서버의 메모리 및 처리 리소스를 소비한다. 각 세션은 일정한 메모리 공간을 차지하며, 세션의 수가 증가함에 따라 서버의 메모리 사용량도 증가할 수 있다.
        
        예) 대규모 서비스로 인한 서버의 메모리 부족 현상: (메모리에 세션을 저장할 경우) ⇒ 메모리(휘발성) 부족할시⇒ 로그인 다 튕길 수 있음. 
        
    2. **세션 관리 오버헤드**: 세션을 관리하기 위해서는 각 세션에 대한 생성, 업데이트 및 만료를 관리해야 한다. 이는 서버 측에서 추가적인 처리를 필요로 하며, 이는 서버의 부담을 증가시킨다. 특히, 많은 사용자가 활동하는 대규모 웹 애플리케이션에서는 더 심하다. 
    3. **세션 저장소 필요성**: 세션 데이터를 저장하려면 서버 측에 데이터베이스나 메모리와 같은 저장소가 필요하다. 이러한 저장소는 추가적인 비용과 관리가 필요하며, 확장성 문제가 발생할 수 있다.
- 확장성 문제
    - 분산 환경에서 여러 서버가 세션을 관리할 경우, 세션 데이터의 일관성을 유지하기 위한 동기화 문제가 발생할 수 있다. 다른 서버에서 불러와야할 경우
    - ‘서버 부담 증가’ 와도 관련

### JWT (Json Web Token)

JWT는 로그인 시 토큰을 발급하고, 이 토큰에 필요한 정보가 들어있기 떄문에 이후 서버는 사용자의 상태를 기억할 필요가 없다. JWT는 헤더(Header), 페이로드(Payload), 서명(Signature) 세 부분으로 구성된다.

- **페이로드(Payload)**: 사용자의 정보등의 데이터(클레임)를 담고 있으며, Base64로 인코딩된다.
    - 누가 발급했나
    - 언제까지 유효한가
    - 사용자에게 토큰을 통해 공개하기 원하는 내용 ex)닉네임, 서비스상의 레벨, 관리자 여부 => 서비스측에서 설정(원하는대로 담기 가능)
    
    사용자가 로그인을 하고 나서 받는 토큰에 정보들이 클레임으로 실려옴 => 요청들마다 사용자로부터 서버한테 보내짐⇒ 사용자가 갖고있는 토큰 자체에 이런 정보들이 들어있음 => 요청마다 일일이 DB등에 접근할 필요 X
    
    특별한 암호화가 아니라 Base64로 인코딩되어있음 -> 사용자가 쉽게 디코딩 가능 => 조작해서 악용하면 어떡하지?
    => 그래서 헤더와 서명 존재
    
- **헤더(Header)**: 토큰의 타입(JWT)과 사용된 암호화 알고리즘을 명시한다.
    - Type: 고정값 JWT
    - alg: 알고리즘의 약자. 서명값을 만드는데 사용되는 알고리이 지정됨.
        
        ex>HS256같은 여러 암호화 방식중 하나 지정할 수 있음.
        
        *암호화 알고리즘= 한쪽 방향으로 계산이 되도 반대쪽으로는 안됨 
        
- **서명(Signature)**: 헤더와 페이로드, 서버의 비밀키를 암호화 알고리즘으로 처리하여 생성한다. 이를 통해 데이터의 무결성을 보장한다.
    - 헤더 +payload+서버에 감춰놓은 비밀키 => 암호화 알고리즘에 넣고 돌림 = 서명값 도출

![token-based-authentication](https://github.com/princess-study/CS-Study/assets/92621272/bcf2676d-0a50-41c6-a7cf-09356599de32)
token-based-authentication[^session] 


1. **로그인**
2. **인증**
3. **토큰 발급**: 사용자가 성공적으로 인증되면, 서버는 사용자를 위한 JWT(JSON Web Token)를 생성한다. 이 JWT에는 사용자의 식별 정보와 필요한 인가 정보가 포함된다.
4. **토큰 전달**: 서버는 생성된 JWT를 클라이언트에게 전달한다. 일반적으로는 HTTP 응답의 헤더나 본문에 포함ㄷ
5. **토큰 저장**: 클라이언트는 받은 JWT를 안전한 곳(예: 브라우저의 로컬 스토리지, 쿠키)에 저장합니다.
6. **요청과 토큰 전송**: 이후 클라이언트가 서버에 요청을 보낼 때마다, JWT를 요청에 포함시킨다.일반적으로는 HTTP 요청의 헤더에 토큰을 포함. 토큰은 보통 "Authorization" 헤더의 "Bearer" 스킴을 사용하여 전송된다.
7. **토큰 검증**: 서버는 클라이언트가 보낸 JWT를 수신하고, 해당 토큰의 유효성을 확인한다. 이 과정에서 서명 검증과 토큰의 만료 여부 등을 확인합니다.
    - 1.서명값과 일치함
    2.유효기간이 지나지 않음 => 로그인된 회원으로써 인가받음.
    비밀키만 있으면 요청들 들어올때마다 확인해서 걸러낼 수 있음 = 시간에 따라 바뀌는 어떠한 상태값을 갖지 않음 = Stateless = 반대로 session은 stateful
8. **인가**: JWT가 유효하고 인증 정보가 정상적으로 확인되면, 서버는 클라이언트의 요청을 수행하고 해당 리소스에 대한 인가를 부여.
9. **응답**: 서버는 클라이언트에게 요청에 대한 응답을 보낸다.  필요에 따라 새로운 토큰을 발급하거나, 토큰의 만료 기간을 연장할 수도 있다.

## 그러나… 세션을 대체하기엔 큰 결점이?

**세션= stateful** = 모든 사용자들의 상태를 기억하고 있음 = 구현하기 부담됨/고려사항 많음 => 하지만 되기만 하면 기억하는 대상의 **상태들을 언제든 제어할 수 있음**. 

예) 한 기기에만 로그인 가능한 서비스
PC에서 로그인한 사용자가 휴대폰에 또 로그인하려 시도하면 PC에선 로그아웃되도록 기존 세션 종료할 수 있음

**JWT에선 이 같은 제어가 불가능한 이유:**
1.이미 발급한 Token을 뺏을 수 없다.
2. 그 토큰의 발급내용이나 정보를 서버가 기록해서 추적하고 있는것도 아님.
즉, 서버가 쥐고있을 필요 없어서 편한데 통제는 힘듦.
토큰을 탈취당할경우 뺏을 방법도 X

**장점**:

- 서버의 부담이 줄어들고, 확장성이 높아진다.
- Stateless(상태 비저장)으로 서비스를 제공할 수 있다. (구현이 비교적 간단하다.)

**단점**:

- 토큰의 만료 기간 관리 필요
- 상태제어 힘듦
- 보안적 취약점 존재: 토큰 탈취 시 대응 방법이 제한적
- Access Token과 Refresh Token의 도입으로 일부 해결 가능
    - 토큰 탈취 보완방법: 만료시간을 아주 짧게 주기=> 그럼 만료될때마다 또 로그인해야하잖아 => 토큰 2개주기
        - 수명이 몇시간~몇분이내인 access 토큰
        - 2주정도로 길게 잡혀있는 refresh토큰
        많은 구현방법중 하나:
        예) access토큰과 refresh토큰을 발급후 클라이언트에 보냄=> refresh토큰의 상응값을 DB에 저장
        => access토큰의 수명이 다하면 refresh토큰 보냄 => 서버: 데이터베이스에 저장된 값과 대조. => 맞다면 새 access token을 발급.
    - refresh토큰만 안전하게 보관되면 유효할 동안은 access토큰이 만료되도 재로그인할 필요없이 새로 발급받을 수 있음
    -access 토큰: 인가를 받을때마다 쓰는 수명짧은 토큰
    -refresh 토큰: access 토큰 재발급시 사용하는 토큰
    - access토큰이 탈취당해도 오래 사용불가
    강제 로그아웃 시키려면 리프레쉬토큰을 DB에서 지워버려서 토큰 갱신 막으면 됨

그래도 여전히 취약점 존재: access 토큰이 살아있는 동안은 차단 불가 => JWT의 한계 

## JWT의 취약점과 보완방법

1. JWT의 보안이슈
    
    간혹 알고리즘에 alg:none으로 해두는 경우=> 공격당함
    => 최신 라이브러리 쓸것(ex)HS256)
    
2. 쉬운 디코딩
    
    페이로드에 최소한의 정보값만 포함할것 (민감한 유저정보 넣지 말것)
    
3. 시크릿 키 
    
    대충쓰는사람 많은데 => 때려맞추기 너무 쉬워짐 => 시크릿키 털리면 입장권 마음대로 발급 가능하게 됨
    1.키를 매우 길게 설정할것
    
    2.공유 금지 
    
    3.생성용/검증용 2개사용(Private key+ Public Key)
    
4. JWT 탈취 
    
    도난당했을때 사용권 중지해주세요=> JWT는 회수못함
    =>  1.훔치기 어려운 저장소에 저장하기
    
    2.JWT블랙리스트 만들기 => 근데 이건 JWT장점 없어짐
    
    3.유효기간 낮춰서(access/refresh)토큰 사용하기 (refresh토큰 한번쓴거 사용x)
    

때문에 JWT만으로 인가구현하는곳은 생각보다 많지않다.

별일없으면 기존 Session방식 사용하는것 권장하나,
회원이 너무 많아서 DB에서 입장권 목록을 제어하는게 너무 힘들다 or 마이크로(하위) 서비스들이 많은 경우 JWT가 더 나을 수 있음.

JWT: 구현하기 편리하고 좋음 => but 적용하기 적합한 서비스인지 충분히 고려해야함 => 큰 이슈가 아닐시에는 정말 편리하고 경제적인 방식이 될 수 있음.

**세션 인가 방식이 적합한 경우:**

- 사용자의 인증 정보를 서버에서 관리하고 싶을 때
- 인증 정보의 변경이나 폐기가 빈번하게 일어날 때
- 서버가 사용자의 상태를 지속적으로 추적하고 싶을 때
- 보안이 매우 중요한 정보를 다룰 때 (세션은 서버 측에서 더 많은 제어가 가능)

**JWT 인가 방식이 적합한 경우:**

- 서버 간 통신이 많은 마이크로서비스 아키텍처에서
- 사용자 인증 정보의 분산 저장이 필요할 때 (각 서비스가 자체적으로 인증을 처리)
- 확장성이 중요한 대규모 시스템에서 (세션 정보를 중앙에서 관리하는 것이 부담스러울 때)
- 인증 정보의 유효기간이 명확하고, 그 기간 동안 자주 변경되지 않을 때

세션은 어디에 저장되는가?


### 참고 사이트

[https://www.youtube.com/watch?v=XXseiON9CV0](https://www.youtube.com/watch?v=XXseiON9CV0)

[https://www.youtube.com/watch?v=St8XcfmWqnw](https://www.youtube.com/watch?v=St8XcfmWqnw)

[https://hudi.blog/session-based-auth-vs-token-based-auth/](https://hudi.blog/session-based-auth-vs-token-based-auth/) **세션 기반 인증과 토큰 기반 인증 (feat. 인증과 인가)** 
[https://hyeon9mak.github.io/session-storage-location/](https://hyeon9mak.github.io/session-storage-location/) 
[https://jwt.io/introduction](https://jwt.io/introduction)
[^session]: *https://hackernoon.com/using-session-cookies-vs-jwt-for-authentication-sd2v3vci*



