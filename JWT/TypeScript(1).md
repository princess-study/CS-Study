# Typescript

**해당 사이트 위주** [https://hashdork.com/top-typescript-interview-questions-and-answers/](https://hashdork.com/top-typescript-interview-questions-and-answers/) 

## 타입스크립트란?

타입스크립트는 대규모 애플리케이션 개발을 위해 설계된 JavaScript의 상위 집합(Superset)입니다. Microsoft가 개발하여 지원 중이며, 정적 타이핑을 도입해 JavaScript의 기능을 확장합니다. 이는 타입스크립트가 자바스크립트의 모든 기능을 포함하면서도, 추가적인 기능, 예를 들어 타입 체크를 제공한다는 의미입니다.

타입스크립트는 "구문상의 상위 집합"이라 표현됩니다. 이는 타입스크립트 코드가 자바스크립트로 컴파일되어 실행되기 때문입니다. 컴파일 과정에서 타입 시스템 관련 코드는 제거되고 순수 자바스크립트 코드만 남습니다. 브라우저는 TypeScript를 직접 실행할 수 없으므로 JavaScript로 변환하는 과정이 필수입니다.

## **TypeScript vs JavaScript**

### **타입스크립트**

- **정적 타입 시스템**: 코드 작성 시 변수와 객체의 타입을 명시적으로 선언해야 함.
- **컴파일 시 오류 감지**: 타입 불일치 등의 오류를 컴파일 시점에 발견할 수 있음.
- **클래스 및 인터페이스**: 객체 지향 프로그래밍을 위한 고급 기능을 제공하며, 타입 체킹에 사용됨.
- **ES6+ 및 그 이상의 자바스크립트 기능 지원**: 최신 자바스크립트 기능을 사용할 수 있으며, 이전 버전의 자바스크립트로 컴파일 가능.
- **자바스크립트의 상위 집합**: 모든 자바스크립트 코드는 타입스크립트에서도 유효함.

### **자바스크립트**

- **동적 타입 시스템**: 변수와 객체의 타입이 실행 시간에 결정됨.
- **런타임 오류 감지**: 대부분의 오류는 코드가 실행될 때 발견됨.
- **프로토타입 기반 상속**: 전통적인 객체 지향 프로그래밍 방식 대신 프로토타입을 사용한 상속. (**ES6에서 클래스 도입)**
- **브라우저와 Node.js에서 직접 실행**: 별도의 컴파일 과정 없이 실행 가능.

타입스크립트는 자바스크립트의 모든 기능을 포함하면서도, 정적 타이핑과 컴파일 시 오류 감지 같은 추가 기능을 제공하여 대규모 애플리케이션 개발 및 유지보수를 용이하게 합니다.
<details>
<summary>인터프리터 vs 컴파일 언어</summary>
<div>

 ### **인터프리터 언어의 특징:**
    
  - **실행 시간에 해석**: 코드가 실행 시간에 한 줄씩 읽혀지고 해석됩니다.
  - **즉각적인 피드백**: 코드 변경 후 결과를 바로 볼 수 있어 개발 과정에서의 피드백 루프가 빠릅니다.
  - **런타임 오류**: 오류가 발생하면 대부분 런타임에서 발견되므로, 때때로 실행 중에만 나타나는 문제를 직면할 수 있습니다.
    
### **컴파일 언어의 특징:**
    
- **사전 분석과 변환**: 코드를 전체적으로 분석하고 기계어나 다른 형태의 중간 코드로 변환하는 컴파일 과정을 거칩니다.
- **오류 감지**: 컴파일 과정에서 문법적 오류나 타입 불일치 등의 문제를 사전에 발견할 수 있습니다.
- **실행 성능**: 컴파일된 코드는 일반적으로 인터프리터 언어에 비해 더 빠른 실행 속도를 제공합니다.
 - **안정성과 유지보수성 향상**: 컴파일 과정에서의 철저한 검사는 코드의 안정성을 높이고, 장기적인 유지보수를 용이하게 합니다.


</div>
</details>

   
## **TypeScript의 주요 목적 및 이점**

 타입스크립트의 주된 목적은 개발 시 타입 안정성과 오류 감지를 통한 개발자의 생산성 향상에 있습니다.

결론적으로, 타입스크립트 자체가 자바스크립트보다 실행 속도를 직접적으로 향상시키지는 않습니다. 실행 속도는 최종적으로 생성된 자바스크립트 코드와 그 코드를 실행하는 자바스크립트 엔진에 의해 결정됩니다. 하지만, 타입스크립트를 사용함으로써 코드의 품질을 향상시키고 잠재적인 성능 문제를 사전에 해결할 수 있는 기회를 얻을 수 있습니다

- **정적 타이핑**: 자바스크립트의 동적 타이핑으로 인해 발생하는 런타임 오류를 줄이고자 타입스크립트에서는 변수, 매개변수, 반환 값 등에 명시적인 타입 지정을 도입했습니다. 이를 통해 개발 단계에서 타입 불일치로 인한 오류를 사전에 감지하고 수정할 수 있습니다.
- **클래스 및 인터페이스**: 타입스크립트의 클래스와 인터페이스는 정적 타입 시스템과 결합되어 있어, 컴파일 시점에 타입 체크와 함께 더욱 견고한 객체 지향 프로그래밍을 가능하게 합니다.
- **고급 타입 기능**: 제네릭, 유니온 타입, 인터섹션 타입, 튜플 등과 같은 고급 타입 기능을 지원하여, 개발자가 더욱 정밀하고 유연하게 타입을 다룰 수 있게 합니다.
- **도구 지원**: 타입스크립트는 통합 개발 환경(IDE)와 편집기에서 더 나은 코드 자동완성, 리팩토링, 타입 검사 등의 기능을 제공합니다. 이는 개발자가 더 빠르고 효율적으로 코드를 작성하고 오류를 수정할 수 있게 해줍니다.


자바스크립트(동적 타이핑)와는 달리,  타입스크립트는 **정적 타입의 컴파일 언어**이며 타입스크립트 컴파일러 또는 바벨(Babel)을 통해 자바스크립트 코드로 변환됩니다. (변환되는 과정에서 사용할 수 있는 도구)
<details>
<summary>tsc와 바벨</summary>
<div markdown="1">

1. **타입스크립트 컴파일러 (tsc)**: 타입스크립트의 공식 컴파일러로, 타입스크립트 코드를 직접 자바스크립트 코드로 변환합니다. 이 과정에서 타입 검사를 수행하며, 설정에 따라 ES5, ES6 등 다양한 자바스크립트 버전으로 코드를 변환할 수 있습니다. 타입스크립트 프로젝트에 가장 기본적으로 사용되는 도구입니다.
2. **바벨 (Babel)**: 자바스크립트 코드를 변환하기 위한 또 다른 트랜스파일러입니다. 최신 자바스크립트(ES6 이상)를 구 버전의 자바스크립트 코드로 변환할 수 있으며, 플러그인을 통해 타입스크립트 코드를 직접 처리하고 자바스크립트로 변환하는 기능도 제공합니다. 
    
    둘 사이의 주요 차이점은 바벨이 타입스크립트의 타입 체크 기능을 직접 수행하지 않는다는 것입니다. 바벨을 사용할 경우, 타입 체크는 별도로 **tsc**를 사용하거나, 다른 도구를 통해 수행해야 합니다. 따라서, 타입스크립트 프로젝트에서는 컴파일과 타입 체크를 위해 **tsc**를 사용하고, 코드 변환과 다른 변환 기능을 위해 바벨을 사용할 수 있습니다.
    

</div>
</details>


### **TypeScript 사용의 이점**

- Javascript에 익숙한 개발자들의 사용 용이성
- 타입 안정성: 명시적인 타입 입력으로 더 안정성있는 코드를 작성가능
- 더 나은 코드 자동완성, 리팩토링 쉬움
- 컴파일시 오류감지 (중요!)
- 타입스크립트는 자바스크립트의 ES6 이후 도입된 객체지향 프로그래밍 기능을 포함하며, 이를 체계적이고 명시적으로 사용가능

### **TypeScript의 단점**

- 초기세팅의 어려움 ⇒ CRP vite 등 사용가능
- 생산성 저하 ⇒ 익숙하지 않은 개발자 (타입 지정하는데 더 시간 할애)
   
[https://www.elancer.co.kr/blog/view?seq=183](https://www.elancer.co.kr/blog/view?seq=183) 참고

## 인터페이스와 타입의 차이

### **인터페이스**

타입스크립트(TypeScript)에서 인터페이스(Interface)는 객체의 구조를 정의하는 역할을 합니다. 변수 타입을 설정할 수 있습니다.

### 타입- 결합유형과 교차 유형

1. **결합 유형(Intersection Types)**: 두 속성을 모두 가져야함
    - 결합 유형은 두 개 이상의 타입을 결합하여 새로운 타입을 만드는 데 사용됩니다.
    - **`&`** 기호를 사용하여 타입을 결합합니다.
    - 결합된 타입은 모든 타입의 속성을 포함합니다.
    - 예를 들어, **`type A = Type1 & Type2`**와 같이 사용할 수 있습니다.
2. **교차 유형(Union Types)**: 이 중에 한 속성만 가지면 됨 
    - 교차 유형은 여러 타입 중 하나를 나타내는 타입을 만드는 데 사용됩니다.
    - **`|`** 기호를 사용하여 타입을 결합합니다.
    - 교차된 타입은 여러 타입 중 하나일 수 있습니다.
    - 예를 들어, **`type B = Type1 | Type2`**와 같이 사용할 수 있습니다.

### **interface**:

- 인터페이스는 객체의 구조를 정의하는 데 주로 사용됩니다.
- 객체의 속성과 메서드를 정의하여 해당 객체의 형태를 명시합니다.
- 인터페이스는 확장(extends)이 가능합니다.

### Type

- 타입 별칭(type alias)은 새로운 타입을 정의할 때 사용됩니다.
- 객체뿐만 아니라 기본 타입, 유니온 타입, 인터섹션 타입 등을 포함하여 다양한 타입을 정의할 수 있습니다.
- 타입 별칭은 유니온 타입이나 인터섹션 타입과 같은 복잡한 타입을 만들 때 유용합니다.
- 타입 별칭은 확장(extends)이 불가능합니다.
    
    

### 유틸리티 타입

타입스크립트에서는  일반적인 타입 변환을 쉽게 하기 위해서 여러가지 유틸리티 타입(Utility Types)을 제공합니다. 이 유틸리티 타입들은 기존 타입을 변형하여 새로운 타입을 생성하는 데 사용됩니다. 이러한 유틸리티 타입들은 코드의 재사용성을 높이고, 복잡한 타입 작업을 단순화하는 데 매우 유용합니다. 

<details>
<summary>유틸리티 타입</summary>
<div markdown="1">

### **1. `Partial<T>`**

- **용도**: 타입 **`T`**의 모든 속성을 선택적으로 만듭니다.
- **활용 예**: 객체를 부분적으로만 업데이트할 때 유용합니다.

```tsx
typescriptCopy code
interface Todo {
    title: string;
    description: string;
}

function updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {
    return { ...todo, ...fieldsToUpdate };
}

```

### **2. `Readonly<T>`**

- **용도**: 타입 **`T`**의 모든 속성을 읽기 전용으로 만듭니다.
- **활용 예**: 불변 객체를 만들 때 사용됩니다.

```tsx
typescriptCopy code
interface Todo {
    title: string;
}

const myTodo: Readonly<Todo> = { title: "Delete inactive users" };

// myTodo.title = "Hello"; // 오류: 'title'은 읽기 전용 속성입니다.

```

### **3. `Record<K, T>`**

- **용도**: 키 **`K`**와 값 **`T`** 타입을 갖는 객체 타입을 생성합니다.
- **활용 예**: 객체의 맵핑을 쉽게 선언할 때 사용됩니다.

```tsx
typescriptCopy code
interface PageInfo {
    title: string;
}

type Page = "home" | "about" | "contact";

const x: Record<Page, PageInfo> = {
    home: { title: "Home" },
    about: { title: "About" },
    contact: { title: "Contact" }
};

```

### **4. `Pick<T, K>`**

- **용도**: 타입 **`T`**에서 속성 **`K`**만을 선택하여 타입을 구성합니다.
- **활용 예**: 특정 속성만을 추출해 새로운 타입을 만들 때 사용됩니다.

```tsx
typescriptCopy code
interface Todo {
    title: string;
    description: string;
    completed: boolean;
}

type TodoPreview = Pick<Todo, "title" | "completed">;

const todo: TodoPreview = {
    title: "Clean room",
    completed: false,
};

```

### **5. `Omit<T, K>`**

- **용도**: 타입 **`T`**에서 속성 **`K`**를 제외한 타입을 구성합니다.
- **활용 예**: 특정 속성을 제외한 타입이 필요할 때 사용됩니다.

```tsx
typescriptCopy code
interface Todo {
    title: string;
    description: string;
    completed: boolean;
}

type TodoPreview = Omit<Todo, "description">;

const todo: TodoPreview = {
    title: "Clean room",
    completed: false,
};

```

이 외에도 **`Exclude<T, U>`**, **`NonNullable<T>`**, **`ReturnType<T>`**, **`InstanceType<T>`** 등 다양한 유틸리티 타입들이 있으며, 각각의 상황에 맞게 활용하여 코드의 타입 안정성을 높일 수 있습니다.

</div>
</details>



### Any

변수의 유형이 명시적으로 지정되지 않고 컴파일러가 컨텍스트에서 이를 확인할 수 없는 경우 TypeScript는 변수가 any 유형이라고 생각합니다.

어떨때 쓰냐: 변수 타입 뭔지 모를때. (사용자 입력이나 API요청(근데 보통은 앎.) 

안쓰는게 좋습니다

타입스크립트의 이점x 
타입명시적으로 지정하려고 타스 쓰는건데 any??

any 사용할바엔 javascript쓰시는게 낫습니다.

### Enum (열거형)

관련된 상수 값들을 그룹화하기 위해 사용됩니다.객체처럼 작성하여 타입열거를 할 수 있습니다.  열거형을 사용하면 숫자나 문자열 값 집합에 더 읽기 쉬운 이름을 부여할 수 있으며, 코드의 가독성과 유지보수성을 향상시킬 수 있습니다.

- 숫자 Enum: 숫자 열거형의 각 멤버는 숫자 값을 가지며, 멤버에 명시적으로 값을 할당하지 않으면 첫 번째 멤버는 **`0`**으로 시작해 이후 멤버는 1씩 증가합니다
- 문자열 열거형 (String Enums):문자열 열거형에서는 각 멤버가 문자열 리터럴로 초기화됩니다. 문자열 열거형은 자동 증가 행위를 제공하지 않으므로 각 멤버는 명시적으로 초기화되어야 합니다.

### Enum은 지양해야한다?

[https://velog.io/@chhw130/enum-타입을-지양해야하는-이유](https://velog.io/@chhw130/enum-%ED%83%80%EC%9E%85%EC%9D%84-%EC%A7%80%EC%96%91%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0)

⇒ TS는 구조적 타이핑을 사용하는데 다른 타입과는 달리 enum의 경우는 명목적 타이핑을 사용합니다. 따라서, enum Something1 { A = 'A' }, enum Something2 { A = 'A' }에서 Something1.A === Something2.A 값은 실제로 같은 문자열임에도 불구하고 false입다.[https://careerly.co.kr/qnas/1392](https://careerly.co.kr/qnas/1392)

⇒ 기존의 type설정에서 typescript는 컴파일 과정에서 제거되는 것과는 달리 enum타입은 추가적인 코드를 발생시킵니다.

⇒ tree-shaking 안됨

트리 쉐이킹(Tree Shaking)은 모던 자바스크립트 번들러와 빌드 도구가 사용하는 최적화 기법 중 하나입니다. 이 기법의 목적은 최종 번들에서 사용되지 않는 코드(dead code)를 제거하여 파일 크기를 줄이고 애플리케이션의 로딩 시간과 성능을 향상시키는 것입니다. 근데? enum타입은 최적화가 안됨. ⇒성능 저하 

### 해결방안?

그래서 나온것: cont enum 

enum 지정시 생겼던 객체나 함수가 사라지고 할당한 값만 남음. 

그런데 사용하는 compiler에 따라서 지원을 하지 않을 수도 있고, 특정 상황에서 ambient enum일 경우 생기는 문제도 있다고 합니다.

### 오버로딩 지원

함수 오버로딩은 같은 이름의 함수를 여러 번 정의하는 것을 의미합니다. 이때 각각의 함수 정의는 서로 다른 매개변수 타입 또는 개수를 가질 수 있습니다. 

 자바스크립트의 경우 전통적인 오버로딩이 되지않고 맨 아랫것을 기준으로 실행되는 반면, 

- 애초에 동적 타이핑이기 때문에 오버로딩의 필요성이 낮은데, 오버로딩같이 동작하도록 구현할 수는 있음

 TypeScript는 함수 오버로딩을 허용합니다. TypeScript에서는 함수 오버로딩을 사용하여 동일한 함수명으로 여러 다양한 매개변수 형태를 처리할 수 있습니다.

- function 키워드로만 함수 오버로딩을 할 수 있으며 arrow function으로는 오버로딩을 할 수 없습니다.
- TypeScript에서 함수 오버로딩은 주로 클래스 내부에서 사용됩니다.

### NoImplicitAny

**`NoImplicitAny`**는 TypeScript의 컴파일 옵션 중 하나로, 암시적인 **`any`** 타입을 허용하지 않도록 강제하는 옵션입니다. TypeScript에서는 변수를 선언할 때 명시적인 타입을 지정하는 것이 권장되지만, 타입을 명시적으로 지정하지 않으면 해당 변수는 암시적인 **`any`** 타입으로 간주됩니다.

**`NoImplicitAny`** 옵션을 활성화하면 TypeScript 컴파일러가 암시적인 **`any`** 타입을 허용하지 않으며, 변수의 타입을 명시적으로 지정하지 않은 경우 컴파일 에러를 발생시킵니다. 이를 통해 TypeScript 코드의 안정성을 높이고 실수를 방지할 수 있습니다. 

## 제네릭이란?

제네릭을 사용하면 함수, 클래스 또는 인터페이스를 작성할 때 타입을 명시적으로 지정하지 않고도 여러 종류의 타입을 처리할 수 있습니다.

제네릭은 타입을 매개변수화하여 사용할 수 있도록 합니다. 이는 함수나 클래스를 작성할 때 사용할 타입을 인자로 받아들이도록 하여, 해당 타입에 의존하는 코드를 일반화하는 것을 의미합니다.

예를 들어, 배열을 반복하면서 각 요소를 출력하는 함수를 작성한다고 가정해보겠습니다. 이 함수는 숫자 배열에 사용할 수 있어야 하지만 문자열 배열에도 동작해야 합니다. 제네릭을 사용하면 이러한 요구사항을 충족할 수 있습니다

```jsx
function printArray<T>(arr: T[]): void {
    for (let item of arr) {
        console.log(item);
    }
}

// 숫자 배열 출력
const numberArray: number[] = [1, 2, 3, 4, 5];
printArray<number>(numberArray);

// 문자열 배열 출력
const stringArray: string[] = ["apple", "banana", "orange"];
printArray<string>(stringArray);

```

JSX는 JavaScript XML의 약어로, JavaScript 안에서 XML 형식으로 UI를 작성할 수 있게 해주는 문법 확장입니다. 주로 React와 함께 사용되지만, TypeScript에서도 일반적으로 사용됩니다. JSX를 사용하면 JavaScript 코드 안에서 HTML과 유사한 구문을 사용하여 UI를 표현할 수 있어서 가독성이 좋고 작성하기 쉽습니다. **TypeScript의 경우 TSX**

주로 리액트와 병행 

html태그같이 생긴 친구들 

```jsx
import React from 'react';

const MyComponent = () => {
    return (
        <div>
            <h1>Hello, World!</h1>
            <p>This is a JSX example.</p>
        </div>
    );
}

export default MyComponent;

```

---
<details>
<summary><b>타입스크립트 엠비언트란? (.d.ts)</b></summary>
<div markdown="1">

## 타입스크립트 엠비언트란? 

앰비언트 모듈은 자바스크립트 라이브러리에 타입스크립트 타입 정보를 제공, 타입 검사와 자동 완성 기능을 가능하게 하여, 실행 시에는 영향 없이 타입스크립트에서 마치 네이티브로 작성된 것처럼 사용할 수 있게 합니다. 실제 코드 실행에는 영향을 주지 않습니다. 앰비언트 모듈 선언은 주로 **`*.d.ts`** 파일 내에서 이루어지며, 이 파일들은 타입 정의 파일로서, 실제 구현이 포함되어 있지 않은 타입 정보만을 담고 있습니다.

### **타입스크립트의 앰비언트(Ambient) 정의**:

- 컴파일 시점에는 존재하지 않지만, 실행 시점에서 제공되는 외부 라이브러리의 타입 정의를 의미합니다.
- 타입스크립트 코드에서 외부 자바스크립트 라이브러리를 안전하게 사용할 수 있도록 타입 정보를 제공합니다.

### **앰비언트의 필요성**:

- 대부분의 자바스크립트 라이브러리는 타입스크립트의 타입 정보를 내장하고 있지 않습니다.
- 이로 인해 타입 검사와 자동 완성 기능을 제대로 활용하기 어렵습니다.###

### **`.d.ts` 파일 (타입 선언 파일)**:

- 실제 구현 코드 없이 타입 정보만을 포함하는 파일입니다.
- 자바스크립트 코드와 타입스크립트 코드 간의 "다리" 역할을 합니다.

### **DefinitelyTyped 저장소**:

- 자바스크립트 라이브러리와 프레임워크의 타입 선언 파일을 대량으로 포함하는 GitHub 저장소입니다.
- **`@types/`** 패키지를 통해 NPM으로 접근 가능, 타입스크립트 프로젝트에서 쉽게 사용할 수 있게 해줍니다.
    
![type](https://github.com/princess-study/CS-Study/assets/92621272/bab9c443-3308-4592-a82f-b3c3c43d3720)

    
- **`npm` 사용**:
    - 타입스크립트 컴파일러 및 타입 정의 파일(**`@types`**)의 설치와 프로젝트 의존성 관리에 사용됩니다.
    - 자바스크립트 생태계와 타입스크립트를 효과적으로 통합합니다.

</div>
</details>

