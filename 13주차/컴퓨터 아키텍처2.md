# 컴퓨터 아키텍처 2

# 컴퓨터의 구성

컴퓨터 시스템은 크게 하드웨어와 소프트웨어로 나누어진다.

**하드웨어** : 컴퓨터를 구성하는 기계적 장치

**소프트웨어** : 하드웨어의 동작을 지시하고 제어하는 명령어 집합

### **하드웨어**

---

- 중앙처리장치(CPU)
- 기억장치 : RAM, HDD
- 입출력 장치 : 마우스, 프린터

### **소프트웨어**

---

- 시스템 소프트웨어 : 운영체제, 컴파일러
- 응용 소프트웨어 : 워드프로세서, 스프레드시트

## 하드웨어

하드웨어는 중앙처리장치(CPU), 기억장치, 입출력장치로 구성되어 있다.

이들은 시스템 버스로 연결되어 있으며, 시스템 버스는 데이터와 명령 제어 신호를 각 장치로 실어나르는 역할을 한다.

### **1. 중앙처리장치(CPU)**

- 주기억장치에서 프로그램 명령어와 데이터를 읽어와 처리하고 명령어의 수행 순서를 제어
- 중앙처리장치는 비교와 연산을 담당하는 **산술논리연산장치(ALU)**와 명령어의 해석과 실행을 담당하는 **제어장치**, 속도가 빠른 데이터 기억장소인 **레지스터**로 구성되어있음
- 개인용 컴퓨터와 같은 소형 컴퓨터에서는 CPU를 마이크로프로세서라고도 부름

### **2. 기억장치**

- 프로그램, 데이터, 연산의 중간 결과를 저장하는 장치
- 주기억장치와 보조기억장치로 나누어지며, RAM과 ROM도 이곳에 해당함. 실행중인 프로그램과 같은 프로그램에 필요한 데이터를 일시적으로 저장
- 보조기억장치는 하드디스크 등을 말하며, 주기억장치에 비해 속도는 느리지만 많은 자료를 영구적으로 보관할 수 있는 장점이 있다.

### **3.입출력장치**

- 입력 장치는 컴퓨터 내부로 자료를 입력하는 장치 (키보드, 마우스 등)
- 출력 장치는 컴퓨터에서 외부로 표현하는 장치 (프린터, 모니터, 스피커 등)

## **시스템 버스**

> 하드웨어 구성 요소를 물리적으로 연결하는 선
> 
- 각 구성요소가 다른 구성요소로 데이터를 보낼 수 있도록 통로가 되어줌
- 용도에 따라 데이터 버스, 주소 버스, 제어 버스로 나누어짐

### **1. 데이터 버스**

중앙처리장치와 기타 장치 사이에서 데이터를 전달하는 통로

기억장치와 입출력장치의 명령어와 데이터를 중앙처리장치로 보내거나, 중앙처리장치의 연산 결과를 기억장치와 입출력장치로 보내는 '양방향' 버스임

### **2. 주소 버스**

데이터를 정확히 실어나르기 위해서는 기억장치 '주소'를 정해주어야 함.

주소버스는 중앙처리장치가 주기억장치나 입출력장치로 기억장치 주소를 전달하는 통로

### **3. 제어 버스**

주소 버스와 데이터 버스는 모든 장치에 공유되기 때문에 이를 제어할 수단이 필요함

제어 버스는 중앙처리장치가 기억장치나 입출력장치에 제어 신호를 전달하는 통로임

제어 신호 종류 : 기억장치 읽기 및 쓰기, 버스 요청 및 승인, 인터럽트 요청 및 승인, 클락, 리셋 등

컴퓨터는 기본적으로 **읽고 처리한 뒤 저장**하는 과정으로 이루어짐

(READ → PROCESS → WRITE)

이 과정을 진행하면서 끊임없이 주기억장치(RAM)과 소통한다. 이때 운영체제가 64bit라면, CPU는 RAM으로부터 데이터를 한번에 64비트씩 읽어온다.

1. **읽기**: 컴퓨터가 데이터나 명령에 액세스해야 할 때 먼저 주 메모리(RAM)에서 검색합니다. 이 프로세스에는 CPU가 RAM에서 데이터를 가져오는 과정이 포함됩니다.
    1. Ram : 사용자가 자유롭게 내용을 읽고 쓰고 지울 수 있는 기억장치. 컴퓨터가 켜지는 순간부터 CPU는 연산을 하고 동작에 필요한 모든 내용이 전원이 유지되는 내내 이 기억장치에 저장된다. '주기억장치'로 분류되며 보통 램이 많으면 한번에 많은 일을 할 수 있기에 '책상'에 비유되곤 한다.
    
2. **처리**: 데이터를 가져오면 CPU가 해당 데이터에 대한 작업을 수행합니다. 여기에는 수신된 명령에 따라 계산, 비교 또는 기타 조작이 포함될 수 있습니다.
3. **저장**: 데이터를 처리한 후 CPU는 결과를 RAM이나 하드 드라이브나 SSD와 같은 다른 저장 장치에 다시 써야 할 수도 있습니다.
   
# **중앙처리장치(CPU) 작동 원리**

---

CPU는 컴퓨터에서 가장 핵심적인 역할을 수행하는 부분. '인간의 두뇌'에 해당

크게 연산장치, 제어장치, 레지스터 3가지로 구성됨

- **연산 장치**
    
    산술연산과 논리연산 수행 (따라서 산술논리연산장치라고도 불림)
    
    연산에 필요한 데이터를 레지스터에서 가져오고, 연산 결과를 다시 레지스터로 보냄
    
- **제어 장치**
    
    명령어를 순서대로 실행할 수 있도록 제어하는 장치
    
    주기억장치에서 프로그램 명령어를 꺼내 해독하고, 그 결과에 따라 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력장치로 보냄
    
    또한 이들 장치가 보낸 신호를 받아, 다음에 수행할 동작을 결정함
    
- **레지스터**
    
    고속 기억장치임
    
    명령어 주소, 코드, 연산에 필요한 데이터, 연산 결과 등을 임시로 저장
    
    중앙처리장치 종류에 따라(용도에 따라) 사용할 수 있는 레지스터 개수와 크기가 다름
    
    - 범용 레지스터 : 연산에 필요한 데이터나 연산 결과를 임시로 저장
    - 특수목적 레지스터 : 특별한 용도로 사용하는 레지스터

### **CPU의 동작 과정**

1. 주기억장치는 입력장치에서 입력받은 데이터 또는 보조기억장치에 저장된 프로그램 읽어옴
2. CPU는 프로그램을 실행하기 위해 주기억장치에 저장된 프로그램 명령어와 데이터를 읽어와 처리하고 결과를 다시 주기억장치에 저장
3. 주기억장치는 처리 결과를 보조기억장치에 저장하거나 출력장치로 보냄
4. 제어장치는 1~3 과정에서 명령어가 순서대로 실행되도록 각 장치를 제어

### **명령어 세트란?**

CPU가 실행할 명령어의 집합

> 연산 코드(Operation Code) + 피연산자(Operand)로 이루어짐
> 
> 
> 연산 코드 : 실행할 연산
> 
> 피연산자 : 필요한 데이터 or 저장 위치
> 

연산 코드는 연산, 제어, 데이터 전달, 입출력 기능을 가짐

피연산자는 주소, 숫자/문자, 논리 데이터 등을 저장

CPU는 프로그램 실행하기 위해 주기억장치에서 명령어를 순차적으로 인출하여 해독하고 실행하는 과정을 반복함

CPU가 주기억장치에서 한번에 하나의 명령어를 인출하여 실행하는데 필요한 일련의 활동을 '명령어 사이클'이라고 말함

명령어 사이클은 인출/실행/간접/인터럽트 사이클로 나누어짐

주기억장치의 지정된 주소에서 하나의 명령어를 가져오고, 실행 사이클에서는 명령어를 실행함. 하나의 명령어 실행이 완료되면 그 다음 명령어에 대한 인출 사이클 시작

# **캐시 메모리(Cache Memory)**

---

속도가 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 말한다.

- 두 구성요소의 최대 성능의 차이로 인해 한 구성요소가 다른 하드웨어의 잠재 성능을 제한하는것

> `ex1) CPU 코어와 메모리 사이의 병목 현상 완화
ex2) 웹 브라우저 캐시 파일은, 하드디스크와 웹페이지 사이의 병목 현상을 완화`
> 
- CPU가 주기억장치에서 저장된 데이터를 읽어올 때, 자주 사용하는 데이터를 캐시 메모리에 저장한 뒤, 다음에 이용할 때 주기억장치가 아닌 캐시 메모리에서 먼저 가져오면서 속도를 향상시킨다.
- 속도라는 장점을 얻지만, 용량이 적기도 하고 비용이 비싼 점이 있다.
- CPU에는 이러한 캐시 메모리가 2~3개 정도 사용된다. (L1, L2, L3 캐시 메모리라고 부른다)
    - 속도와 크기에 따라 분류한 것으로, 일반적으로 L1 캐시부터 먼저 사용된다. (CPU에서 가장 빠르게 접근하고, 여기서 데이터를 찾지 못하면 L2로 감)
    - ***듀얼 코어 프로세서의 캐시 메모리*** : 각 코어마다 독립된 L1 캐시 메모리를 가지고, 두 코어가 공유하는 L2 캐시 메모리가 내장됨
    - 만약 L1 캐시가 128kb면, 64/64로 나누어 64kb에 명령어를 처리하기 직전의 명령어를 임시 저장하고, 나머지 64kb에는 실행 후 명령어를 임시저장한다. (명령어 세트로 구성, I-Cache - D-Cache)
    - L1 : CPU 내부에 존재
    - L2 : CPU와 RAM 사이에 존재
    - L3 : 보통 메인보드에 존재한다고 함

> 캐시 메모리 크기가 작은 이유는, SRAM 가격이 매우 비쌈
> 

***디스크 캐시*** : 주기억장치(RAM)와 보조기억장치(하드디스크) 사이에 존재하는 캐시

### **캐시 메모리 작동 원리**

- **시간 지역성 :** for나 while 같은 반복문에 사용하는 조건 변수처럼 한번 참조된 데이터는 잠시후 또 참조될 가능성이 높음
- **공간 지역성 :** A[0], A[1]과 같은 연속 접근 시, 참조된 데이터 근처에 있는 데이터가 잠시후 또 사용될 가능성이 높음

캐시에 데이터를 저장할 때는, 이러한 참조 지역성(공간)을 최대한 활용하기 위해 해당 데이터뿐만 아니라, 옆 주소의 데이터도 같이 가져와 미래에 쓰일 것을 대비한다.

CPU가 요청한 데이터가 캐시에 있으면 'Cache Hit', 없어서 DRAM에서 가져오면 'Cache Miss'

# **고정 소수점 & 부동 소수점**

---

컴퓨터에서 실수를 표현하는 방법은 `고정 소수점`과 `부동 소수점` 두가지 방식이 존재한다.

1. **고정 소수점(Fixed Point)**
    
    > 소수점이 찍힐 위치를 미리 정해놓고 소수를 표현하는 방식 (정수 + 소수)
    > 
    > - `3.141592는 부호(-)와 정수부(3), 소수부(0.141592) 3가지 요소 필요함`
    
    !http://tcpschool.com/lectures/img_c_fixed_point.png
    
    **장점** : 실수를 정수부와 소수부로 표현하여 단순하다.
    
    **단점** : 표현의 범위가 너무 적어서 활용하기 힘들다. (정수부는 15bit, 소수부는 16bit)
    
    ![f611a9c17d2ed9cfec4180ea111f4483ed832e96fe7790b145931f8c1a6b9da2.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/aee84880-96fd-4e10-90fc-a19384342fd0/aa71d2d5-4c13-41bf-aa98-b0b16d33bd76/f611a9c17d2ed9cfec4180ea111f4483ed832e96fe7790b145931f8c1a6b9da2.png)
    

![img1.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/aee84880-96fd-4e10-90fc-a19384342fd0/676e15a8-165f-4967-8a97-2111cb1a1a03/img1.png)

1. **부동 소수점(Floating Point)**
    
    > 실수를 가수부 + 지수부로 표현한다.
    > 
    > - 가수 : 실수의 실제값 표현
    > - 지수 : 크기를 표현함. 가수의 어디쯤에 소수점이 있는지 나타냄
    
    **지수의 값에 따라 소수점이 움직이는 방식**을 활용한 실수 표현 방법이다.
    
    즉, 소수점의 위치가 고정되어 있지 않는다.
    
    !http://tcpschool.com/lectures/img_c_floating_point_32.png
    
    **장점** : 표현할 수 있는 수의 범위가 넓어진다. (현재 대부분 시스템에서 활용 중)
    
    **단점** : 오차가 발생할 수 있다. (부동소수점으로 표현할 수 있는 방법이 매우 다양함)
    
    ![150e6ff4ef7a02673d86aa0caae3ecbca2c168364ae1f153ee25660e1ea2a017.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/aee84880-96fd-4e10-90fc-a19384342fd0/4b6443d5-3838-43c8-99f6-dd5d824ff797/150e6ff4ef7a02673d86aa0caae3ecbca2c168364ae1f153ee25660e1ea2a017.png)
    
    ![img2.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/aee84880-96fd-4e10-90fc-a19384342fd0/0c5bd790-70de-4fa9-9442-79cf63380313/img2.png)
    

# **패리티 비트 & 해밍 코드**

---

### **패리티 비트**

> 정보 전달 과정에서 오류가 생겼는 지 검사하기 위해 추가하는 비트를 말한다.
> 
> 
> 전송하고자 하는 데이터의 각 문자에 1비트를 더하여 전송한다.
> 

**종류** : 짝수, 홀수

전체 비트에서 (짝수, 홀수)에 맞도록 비트를 정하는 것

***짝수 패리티일 때 7비트 데이터가 1010001라면?***

> 1이 총 3개이므로, 짝수로 맞춰주기 위해 1을 더해야 함
> 
> 
> 답 : 11010001 (맨앞이 패리티비트)
> 

### **해밍 코드**

> 데이터 전송 시 1비트의 에러를 정정할 수 있는 자기 오류정정 코드를 말한다.
> 
> 
> 패리티비트를 보고, 1비트에 대한 오류를 정정할 곳을 찾아 수정할 수 있다. (패리티 비트는 오류를 검출하기만 할 뿐 수정하지는 않기 때문에 해밍 코드를 활용)
> 

### **방법**

2의 n승 번째 자리인 1,2,4번째 자릿수가 패리티 비트라는 것으로 부터 시작한다. 이 숫자로부터 시작하는 세개의 패리티 비트가 짝수인지, 홀수인지 기준으로 판별한다.

***짝수 패리티의 해밍 코드가 0011011일때 오류가 수정된 코드는?***

1. 1, 3, 5, 7번째 비트 확인 : 0101로 짝수이므로 '0'
2. 2, 3, 6, 7번째 비트 확인 : 0111로 홀수이므로 '1'
3. 4, 5, 6, 7번째 비트 확인 : 1011로 홀수이므로 '1'

역순으로 패리티비트 '110'을 도출했다. 10진법으로 바꾸면 '6'으로, 6번째 비트를 수정하면 된다.

따라서 **정답은 00110'0'1**이다.

## 참조

- [https://gyoogle.dev/blog/computer-science/computer-architecture/중앙처리장치 작동 원리.html](https://gyoogle.dev/blog/computer-science/computer-architecture/%EC%A4%91%EC%95%99%EC%B2%98%EB%A6%AC%EC%9E%A5%EC%B9%98%20%EC%9E%91%EB%8F%99%20%EC%9B%90%EB%A6%AC.html)
- https://namu.wiki/w/RAM
- https://www.crucial.kr/articles/about-memory/support-what-does-computer-memory-do
- https://www.koya-culture.com/news/article.html?no=117094
- https://www.intel.co.kr/content/www/kr/ko/gaming/resources/what-is-bottlenecking-my-pc.html
- https://tagilog.tistory.com/596

### 폰노이만 구조

- 데이터와 명령이 모두 동일한 메모리에 저장되므로 CPU가 이를 순차적으로 처리할 수 있습니다.

### 컴퓨터 병목현상

- 병목 현상은 두 구성요소의 최대 성능의 차이로 인해 한 구성요소가 다른 하드웨어의 잠재 성능을 제한하는것
- CPU, 메모리, 디스크 등 시스템의 자원 중 하나가 다른 자원보다 처리 속도가 느려 전반적인 성능이 제한되는 경우 발생
- 병목현상을 해결하기 위해서는 효율적인 자원배분과 최적화가 필요

### 프로세스와 스레드

- 프로세스 :   프로세스(process)란 단순히 실행 중인 프로그램(program)이라고 할 수 있습니다. 즉, 사용자가 작성한 프로그램이 운영체제에 의해 메모리 공간을 할당받아 실행 중인 것을 말합니다. 이러한 프로세스는 프로그램에 사용되는 데이터와 메모리 등의 자원 그리고 스레드로 구성됩니다.
- 스레드 :  스레드(thread)란 프로세스(process) 내에서 실제로 작업을 수행하는 주체를 의미합니다. 모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행합니다. 또한, 두 개 이상의 스레드를 가지는 프로세스를 멀티스레드 프로세스(multi-threaded process)라고 합니다.

### 모듈 번들러

모듈 번들러란 JavaScript 모듈을 브라우저에서 실행할 수 있는 단일 JavaScript 파일로 묶는데 사용되는 도구이다. 모듈 번들러는 크게 세 가지 이유로 사용된다.

- 모든 브라우저가 모듈 시스템을 완전하게 지원하지 않는다.
- 코드의 종속성 관계를 관리하는데 도움이 되며 종속성 순서대로 모듈을 로드한다.
- 이미지 에셋, css 에셋 등 종속성 순서대로 에셋을 로드하는 데 도움이 된다.

최근에는 번들러 자체에서 개발과 빌드, 최적화를 위한 각종 플러그인을 제공하고 있으므로 별도의 최적화 도구를 사용하지 않아도 되게 되었다. 이것이 바로 모던 웹 애플리케이션을 작성할 때 일반적으로 별도의 추가적인 툴을 사용하지 않는 이유

### 메모리란

컴퓨터 메모리라고도 알려진 RAM

본질적으로 RAM은 **컴퓨터나 노트북의 단기 기억 장치**입니다. 컴퓨터 프로세서가 응용 프로그램을 실행하고 파일을 여는 데 필요한 데이터가 저장되는 곳

### 레지스터 설명

프로세서에 위치한 고속 메모리로 극히 소량의 데이터나 처리 중인 중간 결과와도 같은 프로세서가 바로 사용할 수 있는 데이터를 담고 있는 영역을 레지스터라고 한다. 컴퓨터 구조에 따라 크기와 종류

### CPU, 레지스터, 메모리(RAM)

레지스터는 현재 CPU(프로세서)가 처리하고 있는 데이터를 보유

- 영구적으로 저장할 데이터는 하드디스크에 저장
- 임시적으로 저장하는 장소는 메모리(RAM)이다.

### 레지스터란

CPU에서 연산을 하고 이 연산의 결과를 보내고, 영구적으로 저장할 데이터를 하드디스크에 보내는 등의 이러한 명령들과 이들에 대한 주소를 저장할 수 있는 임시저장 기억공간이 필요한데, 이러한 명령들을 아주 빠르게 할 수 있는 것이 CPU옆에 있는 레지스터인 것이다. CPU에서는 자체적으로 데이터를 저장할 방법이 없고  메모리로 직접 데이터를 전송할 수 없기 때문에 연산을 하기 위해서는 레지스터를 반드시 거쳐야한다.

### 힙 영역

프로그램이 운영체제로부터 할당받는 대표적인 메모리 공간 4가지중 하나, 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됨, 메모리 크기제한 x

### 웹팩과 바이트

웹팩은 모듈 번들러이다.
모듈 번들러는?? 웹 어플리케이션을 이루는 수많은 자원들이 있는데, 이것들을 조합하고 압축해서 하나의 결과물로 만들어준다.

### 웹팩의 필요성

1. 코드 의존성을 따져서 파일들을 압축, 조합해서 웹 어플리케이션을 빠르고 효율적으로 로딩되게 해준다.
2. 변수의 scope(유효 범위) 문제를 해결해준다.
3. 웹 개발 작업을 자동화해준다.

### **Vite**

**비트(Vite) (opens new window)**는 기존의 프런트엔드 개발 경험을 향상시켜줄 새로운 프런트엔드 툴

### 웹팩이 있는데 비트와 같은 도구들이 나온 이유

웹팩을 사용할 때보다 훨씬 더 빠르게 개발하고 배포할 수 있기 때문

1. CRA
- 사용하지 않는 기능까지 전부 설치되기 때문에 모듈 사이즈가 크다.
- 커스텀 빌드를 하는 것이 어렵다.
1. Webpack
- 개발 서버 시작할 때, 모든 모듈을 합치기 때문에 느리다.
- 간단한 작업도 플러그인이 필요하다.
- 번들 사이즈가 너무 크다.
1. Rollup.js
- 웹팩에 대한 최소한의 대안이며 소규모 프로젝트에 적합하다.
- 규모가 커질수록 설정이 복잡해진다.
1. Parcel
- 소규모 프로젝트에 적합한 번들러이다.
