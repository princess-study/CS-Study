# 자료구조

### **자료구조란?**

효율적으로 데이터를 관리하고 수정, 삭제, 탐색, 저장할 수 있는 데이터 집합

- 효율적인 자료구조가 성능 좋은 알고리즘의 기반이 됨.
- 자료의 효율적인 관리는 프로그램의 수행 속도와 밀접한 관련이 있음
- 여러 자료구조 중에서 구현하려는 프로그램에 맞는 최적의 자료구조를 활용해야 해서 자료구조에 대한 이해가 중요

### **선형 자료구조**

- 데이터 요소가 순차적 또는 선형으로 배열되고 일대일 관계에 있으며 각 요소가 이전 및 다음 인접 요소에 연결되는 자료구조
    - **정적 자료구조** : 프로그램 실행 중에 크기가 고정되어 있는 자료구조 배열은 정적 자료구조의 대표적인 예로 선언시 배열의 크기가 정해지고 이후에 변경 불가. 미리 할당된 메모리 공간에 데이터를 저장하기 때문에 데이터 추가, 삭제, 크기 변경 등이 제한적
    - **동적 자료구조** : 프로그램 실행 중 크기가 동적으로 조정될 수 있는 자료구조 필요에 따라 메모리에서 유연하게 공간을 할당하고 해제해 데이터를 저장할 수 있어 데이터 추가, 삭제, 크기 변경 등이 가능함.
      - 대표적인 예로 **ArrayList, LinkedList, Queue, Stack** 등이 있음
        

### **비선형 자료구조**

- 데이터 요소가 순차적 또는 선형으로 배치되지 않은 자료구조 계층 구조를 가지며 요소들 간에 관계를 표현하기 위해 사용됨.
- 대표적인 예로 **Tree, Graph** 등이 있음.
    

## 선형 자료구조


### **연결 리스트 (LinkedList)**

- 데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화시킨 자료구조
- 각 요소가 인접한 메모리 위치에 저장되지 않는 선형 자료구조
- 자료가 추가될 때마다 메모리를 할당 받고, 자료는 링크로 연결됨.
- 자료의 물리적 위치와 논리적 위치가 다를 수 있음.
- 스택, 큐, 그래프 등을 구현하는데 사용
- 첫 번째 노드는 Head, 마지막 노드의 다음 포인터는 항상 NULL

**종류**

**싱글 연결 리스트:** next 포인터만 가진다.

**이중 연결 리스트:** next 포인터와 prev 포인트를 가진다.

- 장점: 연속적인 탐색&액세스가 이루어져야 하는 경우 탐색 시간 절감
- 단점: 포인터를 위한 공간이 2배로 사용
- 각 노드의 포인터 변수는 다음 노드의 **데이터의 주소를 값으로** 가진다. 또한 각 포인터 변수의 주소도 따로 존재한다.

### 배열(정적)

- 연속적인 메모리 공간에 **순차적**으로 데이터를 저장한다.
- 배열은 선언할 때 크기를 정하면, 그 크기로 **고정**이 된다.
- 선언된 값은 다시 배열을 선언하지 않으면 **변경할 수 없다**.
- 각 요소의 인덱스 접근이 용이하고 **랜덤 접근**이 가능하다.

**동적 배열**

- 특정 위치의 데이터를 호출하거나 추가하는 것을 O(1) 에 처리할 수 있다.
    - 동적 배열은 배열을 이용하여 구현되어 있기 때문에 데이터들이 메모리의 연속된 위치에 저장되어 있고, 각 데이터들은 번호(Index)를 가지고 있다. 그래서 특정 위치의 데이터를 호출하거나 변경하는 O(1)에 처리할 수 있다.
- 배열의 크기를 변경하는 resize() 연산을 O(N)에 처리할 수 있다
    - resize() 연산은 새로운 배열을 만들어 기존 배열의 데이터를 복사하는 작업이기 때문에 기존 배열의 크기에 비례하여 시간이 소요된다. 그렇기 때문에 resize() 연산은 O(N)에 처리 된다.
- 데이터를 배열의 맨 끝에 추가하는 append() 연산을 O(1)에 처리할 수 있다.
    - 동적 배열의 append() 연산이 O(1)에 처리 될 수 있는 것은 동적 배열의 재할당 전략 덕분이
    - 동적 배열의 재할당 전략은 새로운 배열의 크기를 기존 배열의 크기를 2배 만큼 늘리는 것이다.
    - 동적 배열은 1 -> 2 -> 4 -> 8 -> 16 순으로 메모리 크기를 늘려 가는 것이다.
    - append() 연산 마다 새로운 배열의 크기를 기존 보다 1씩 늘려 데이터를 저장하면 매번 resize() 연산을 해야 하기 때문에 append() 연산이 O(N)이 되어 선형이되버린다.
    - 그래서 아래 그림과 같이 메모리에서 할당 받은 크기(capacity) 만큼 데이터 수(size) 가 채워졌을 때 기존 배열 크기 보다 **2배** 만큼의 크기를 메모리에서 할당 받아서 저장 공간을 넉넉하게 만든다. 그러면 그 다음부터 append() 할 때 데이터를 빈 공간에 순서대로 채워 넣으면 되기 때문에 append()을 O(1)에 처리 할 수 있는 것이다.

### **배열(정적)과 연결리스트 비교**

**배열**

- 랜덤 접근 가능 O(1)
- 데이터 참조에 용이 → 데이터 추가 삭제 시 모든 배열 요소를 앞으로 옮겨야 하므로 O(n)의 복잡도를 가짐

**연결리스트**

- 랜덤 접근 불가능 O(n) → 선을 기반으로 순차적으로 접근해야 함
- 데이터 추가 삭제에 용이 O(1) → 선을 바꿔 연결해주면 됨

### 스택

- 가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 성질 **후입선출(LIFO, Last In First Out)**을 가진 자료 구조
- 재귀 함수, 브라우저 방문 기록, 뒤로 가기(?), 문서 편집기의 되돌리기 기능 등에 쓰인다. 프링글스..?
- 삽입 및 삭제에 O(1), 탐색에 O(n)이 걸린다.
- 출력 순서가 입력 순서의 역순으로 이루어질 때 아주 요긴하게 사용되는 자료구조

### 큐

- 먼저 집어넣은 데이터가 먼저 나오는 성질 **선입선출(FIFO, First In First Out)**
- 스택과 반대 개념
- CPU 작업을 기다리는 프로세스, 스레드 행렬, 네트워크 접속을 기다리는 행렬, 너비 우선 탐색, 캐시 등에 사용
- 삽입 및 삭제에 O(1), 탐색에 O(n)이 걸린다.
- 큐에 `끝(Rear)`에서 요소를 추가하는 작업을 `enqueue`라고 하며 큐에 `맨 앞(Front)`에서 요소를 제거하는 작업을 `dequeue`라고 한다.
- 가득 찬 큐에 요소를 추가하려고 할 때 `Overflow`가 발생하며, 빈 큐에서 요소를 제거하려고 할 때 `Underflow`가 발생합니다.
<br/><br/><br/>


---

[https://wooooozin.tistory.com/entry/자료구조-자료구조란-무엇이고-선형비선형-자료구조란](https://wooooozin.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-%EC%84%A0%ED%98%95%EB%B9%84%EC%84%A0%ED%98%95-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EB%9E%80)

https://code-lab1.tistory.com/2

https://noahlogs.tistory.com/29

[https://roi-data.com/entry/자료구조-4-스택Stack이란-연산-구현방법](https://roi-data.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-4-%EC%8A%A4%ED%83%9DStack%EC%9D%B4%EB%9E%80-%EC%97%B0%EC%82%B0-%EA%B5%AC%ED%98%84%EB%B0%A9%EB%B2%95)

https://yoongrammer.tistory.com/46