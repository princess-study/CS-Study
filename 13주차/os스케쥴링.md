
# CPU 스케줄링 이해와 알고리즘

## 👉👉[링크](https://runa-nam.tistory.com/88)

## 개요
CPU 스케줄링은 다중 프로그램 환경에서 CPU 자원을 효율적으로 관리하고, 프로세스간 공정한 자원 분배를 촉진하여 시스템의 전반적인 성능을 최적화하는 운영체제의 핵심 기능입니다. 이 과정을 통해 각 프로세스는 적절한 CPU 시간을 할당받아 실행됩니다.

## 스케줄링의 기본 원리
- CPU - I/O 버스트 사이클
프로세스의 생명주기는 CPU 버스트(계산 처리)와 I/O 버스트(입출력 대기)의 사이클로 구성됩니다. 이 사이클은 프로세스의 실행 동안 반복적으로 발생하며, 마지막 CPU 버스트는 종종 시스템의 종료 요청과 함께 끝나게 됩니다.

- CPU 스케줄러
운영체제의 CPU 스케줄러는 CPU가 유휴 상태가 될 때마다 준비 큐(Ready Queue)에 있는 프로세스 중 하나를 선택하여 실행합니다. 이 큐는 FIFO, 우선순위 큐, 트리 등 다양한 자료구조로 구현될 수 있으며, 큐에 있는 각 항목은 프로세스의 프로세스 제어 블록(PCB)을 포함합니다.

- 디스패처
디스패처는 CPU 스케줄러에 의해 선택된 프로세스에 CPU 제어를 전달하는 역할을 합니다. 이 과정에는 문맥 교환, 사용자 모드로의 전환, 프로그램의 적절한 위치로의 점프 등이 포함되며, 디스패치 지연이라고 하는 지연 시간이 발생합니다.

## 주요 스케줄링 알고리즘
- 선입 선처리 (FCFS: First-Come, First-Served)
가장 단순한 형태의 스케줄링 알고리즘으로, 먼저 도착한 프로세스가 먼저 CPU를 할당받습니다. 이 방법은 구현이 쉽지만, 긴 프로세스가 짧은 프로세스를 블로킹하는 컨보이 효과로 인해 비효율적일 수 있습니다.

- 최단 작업 우선 (SJF: Shortest Job First)
각 프로세스의 다음 CPU 버스트 길이를 예측하고, 가장 짧은 것을 먼저 스케줄하는 방식입니다. 이론적으로 최소의 평균 대기 시간을 제공하지만, 버스트 길이를 정확히 예측하기 어렵다는 단점이 있습니다.

- 라운드 로빈 (RR: Round Robin)
각 프로세스는 동일한 크기의 시간 할당량(타임 슬라이스)을 받고, 할당 시간이 끝나면 준비 큐의 맨 뒤로 이동합니다. 이 방법은 공평성을 제공하지만, 시간 할당량의 크기에 따라 성능이 크게 달라질 수 있습니다.

- 우선순위 스케줄링
프로세스마다 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스가 CPU를 먼저 할당받습니다. 내부적 또는 외부적으로 우선순위를 정할 수 있으며, 기아 상태와 무한 봉쇄를 방지하기 위한 메커니즘이 필요합니다.

- 다단계 큐 스케줄링
프로세스를 여러 큐로 분류하고, 각 큐는 독립적인 스케줄링 알고리즘(예: 하나는 FCFS, 다른 하나는 RR)을 가집니다. 이 방법은 프로세스의 특성에 따라 다양한 스케줄링 필요성을 충족시킬 수 있습니다.

- 다단계 피드백 큐 스케줄링
다단계 큐 스케줄링의 확장형으로, 프로세스가 실행 중에 다른 큐로 이동할 수 있습니다. 이는 프로세스의 우선순위를 동적으로 조절하여 보다 유연한 스케줄링을 가능하게 합니다.

## 스케줄링의 성능 평가
CPU 이용률과 처리량을 최대화하는 것이 목표입니다.
턴어라운드 시간, 대기 시간, 응답 시간을 최소화하는 것도 중요합니다.
효과적인 스케줄링은 이러한 지표들 사이의 적절한 균형을 찾는 것입니다.
스케줄링 알고리즘의 선택은 특정 시스템의 요구 사항과 운영 환경에 따라 달라질 수 있으며, 각 알고리즘의 이점과 제한 사항을 이해하는 것이 중요합니다.
