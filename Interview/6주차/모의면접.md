# **DOM(Document Object Model)의 필요성 및 역할**

DOM은 웹 페이지의 구조를 표현하고, 스크립팅 언어(주로 자바스크립트)가 해당 구조를 조작할 수 있는 인터페이스를 제공합니다. 이를 통해 동적으로 웹 페이지의 내용을 변경하거나 사용자와의 상호작용을 처리할 수 있습니다. DOM은 HTML이나 XML 문서를 트리 구조로 표현하여 각 요소에 접근하고 조작할 수 있도록 합니다.

## ***자바스크립트 자체는 싱글 쓰레드가 맞지만 자바스크립트 런타임은 싱글 쓰레드가 아니다.***

- 자바스크립트 자체는 싱글 쓰레드가 맞지만 자바스크립트 런타임은 멀티 쓰레드이다.

자바스크립트는 싱글 스레드 언어이며, 이는 한 번에 하나의 작업만을 처리할 수 있다는 것을 의미합니다. 이는 자바스크립트가 동시에 여러 작업을 처리할 수 없다는 것을 의미합니다. 그러나 웹 브라우저나 Node.js와 같은 자바스크립트 런타임 환경은 멀티 스레드로 동작합니다.

웹 브라우저 환경에서, 자바스크립트는 주로 단일 스레드인 메인 스레드에서 실행됩니다. 하지만 웹 API (예: setTimeout, XMLHttpRequest, fetch 등)를 통해 비동기 작업을 처리하고, 이벤트 루프를 통해 이러한 비동기 작업들의 결과를 콜백 함수로 처리합니다.

예를 들어, setTimeout 함수는 웹 API에 의해 비동기로 실행되며, 일정 시간이 지난 후에 콜백 함수를 실행하도록 예약합니다. 이때 메인 스레드는 다른 작업을 계속해서 처리할 수 있습니다. 비슷하게, XMLHttpRequest나 fetch 함수를 사용하여 서버로부터 데이터를 요청할 때도 웹 API가 비동기적으로 데이터를 가져오고, 이벤트 루프를 통해 결과를 처리합니다.

Node.js 환경에서도 비슷한 개념이 적용됩니다. Node.js는 싱글 스레드로 동작하지만, libuv라는 라이브러리를 통해 비동기 I/O 작업을 처리하고, 이벤트 루프를 통해 결과를 처리합니다. 이를 통해 Node.js는 싱글 스레드로서의 효율성을 유지하면서도 다수의 요청을 동시에 처리할 수 있습니다.

이러한 멀티 스레드 환경에서 자바스크립트는 싱글 스레드로 동작하며, 웹 API 및 이벤트 루프를 통해 비동기 작업을 처리하고 결과를 콜백 함수로 전달합니다. 이를 통해 동시성을 지원하면서도 싱글 스레드의 장점을 유지할 수 있습니다.

# CRUD가 뭔가요?

**CRUD**는 대부분의 컴퓨터 소프트웨어가 가지는 기본적인 **데이터 처리 기능**인 **Create(생성), Read(읽기), Update(갱신), Delete(삭제)** 를 묶어서 일컫는 말이다. 사용자 인터페이스가 갖추어야 할 기능(정보의 참조/검색/갱신)을 가리키는 용어로서도 사용된다.

- 데이터 베이스에서의 CRUD는 기초적인 4가지 쿼리 형식을 의미하기도 한다.
    
    
    | 이름 | 조작 | SQL |
    | --- | --- | --- |
    | Create | 생성 | INSERT |
    | Read | 조회 | SELECT |
    | Update | 수정 | UPDATE |
    | Delete | 삭제 | DELETE |
- 클라이언트 <-> 서버간 HTTP 프로토콜을 이용해 RESTful하게 데이터를 전송할 때도 CRUD 개념이 활용된다.
    
    
    | 이름 | 조작 | Method |
    | --- | --- | --- |
    | Create | 생성 | POST |
    | Read | 읽기 | GET |
    | Update | 갱신 | PUT |
    | Delete | 삭제 | DELETE |

한마디로, **Create로 데이터를 생성하고 Read로 데이터를 읽으며 Update로 새로운 데이터를 업데이트하고 Delete로 데이터를 삭제하는 것이다.**

# ***RestAPI란***

- REST란 REpresentational State Trasfer의 약어로 웹을 이용할 때 제약 조건들을 정의하는 소프트웨어 아키텍처 스타일입니다.
- HTTP URL을 통해 자원(Resource)을 명시하고 HTTP Method(GET, POST, PUT, DELETE)를 통해서 해당 자원(URL)에 대한 CRUD(Create, Read, Update, Delete)를 적용하는 것을 의미합니다.
- HTTP의 장점을 살리고자 하는 통신 규약이라 할 수 있습니다.

# ***REST 특징 6가지***

- **인터페이스 일관성** : 일관적인 인터페이스로 분리되어야 합니다.
- **무상태** : 각 요청 간 클라이언트의 context, 세션과 같은 상태 정보를 서버에 저장하지 않습니다.
- **캐시 처리 가능** : 클라이언트는 응답을 캐싱할 수 있어야 합니다. 캐시를 통해 대량의 요청을 효율적으로 처리할 수 있습니다.
- **계층화** : 클라이언트는 대상 서버에 직접 연결되어있는지, Proxy를 통해서 연결되었는지 알 수 없습니다.
- **Code on demand** : 자바 애플릿이나 자바스크립트의 제공을 통해 서버가 클라이언트를 실행시킬 수 있는 로직을 전송하여 기능을 확장시킬 수 있습니다.
- **클라이언트/서버 구조** : 아키텍처를 단순화시키고 작은 단위로 분리함으로써 클라이언트-서버의 각 파트가 독립적으로 구분하고 서로 간의 의존성을 줄입니다.

# **Promise와 async/await**

Promise는 비동기 작업의 결과를 다루기 위한 객체로, 성공 또는 실패와 같은 상태를 처리합니다. async/await는 Promise를 기반으로 하며, 비동기 코드를 동기적으로 작성할 수 있도록 해줍니다. 이는 가독성을 높이고, 에러 처리를 간편하게 해 줍니다.

# async await 가 Promise보다 좋은 이유?

1. **가독성과 유지보수성 향상**: **`async/await`**는 코드의 가독성을 향상시킵니다. 콜백 함수를 체이닝하는 것보다 선언적이고 직관적인 코드를 작성할 수 있습니다. 이는 코드를 이해하고 유지보수하는 데 도움이 됩니다.
2. **동기적인 코드처럼 보임**: **`async/await`**를 사용하면 비동기 코드를 동기적으로 보이게 할 수 있습니다. 이는 개발자가 비동기적인 코드를 작성할 때 일반적인 동기적인 코드 스타일을 유지할 수 있게 합니다.
3. **오류 처리가 용이**: **`try/catch`** 블록을 사용하여 오류 처리를 할 수 있습니다. 이는 비동기 코드 내에서 발생하는 오류를 쉽게 처리할 수 있게 해줍니다. 또한 **`async/await`**는 프로미스 체인에서 오류를 처리하는 것보다 간단하고 직관적입니다.
4. **동기적인 코드와 성능**: **`async/await`**는 실제로 동기적인 코드처럼 보이지만 내부적으로는 비동기적으로 동작합니다. 이는 코드의 가독성과 유지보수성을 향상시키면서도 비동기 코드의 성능을 유지합니다.
5. **호환성**: **`async/await`**는 프로미스 기반의 비동기 코드와 완벽하게 호환됩니다. 따라서 기존의 프로미스 기반 코드를 쉽게 **`async/await`**로 전환할 수 있습니다.

이러한 이유들로 **`async/await`**는 보다 간결하고 가독성이 높은 비동기 코드 작성을 가능하게 합니다.