## 리엑트 쿼리 장점

-   MobX나 Redux를 사용하다 보면 BoilerPlate 형태의 코드가 많이 발생하게 되는데, React-Query는 비교적 코드의 양이 적고 구조가 단순하여 추후 유지 보수가 용이
-   Caching을 통해 애플리케이션의 속도를 향상시킴 동일한 데이터에 대한 중복 요청을 제거
-   오래된 데이터의 상태를 파악하여 updating을 지원 Garbage Collection(GC)을 이용하여 서버 쪽 데이터 메모리를 관리
-   React Hooks와 유사한 인터페이스를 제공 비동기 과정을 선언적으로 관리 가능

## 리엑트 쿼리에서 옵저버와 쿼리

1. **옵저버(Observer)**옵저버는 React Query에서 비동기 데이터 요청을 추적하고 업데이트를 처리하는 객체입니다. 주요 역할은 쿼리의 상태 변화를 감지하고 이에 따라 UI를 업데이트하는 것입니다. **React Query에서 제공하는 useQuery 또는 useMutation hook을 사용하여 옵저버를 생성**합니다. 다양한 상태 변경 이벤트에 대한 콜백 함수 등 옵저버를 통해 쿼리의 상태 변화를 감지하고 UI를 업데이트할 수 있습니다.🔎 옵저버는 다음과 같은 속성을 가질 수 있습니다

    > isLoading: 요청이 진행 중인지 여부를 나타냅니다.
    >
    > isError: 요청이 실패했는지 여부를 나타냅니다.
    >
    > data: 요청에서 받은 데이터를 저장합니다.
    >
    > error: 요청 실패 시 발생한 오류를 저장합니다.
    >
    > refetch: 요청을 다시 실행하는 함수입니다.

2. **쿼리(Query)**쿼리는 React Query에서 비동기 데이터 요청을 나타내는 객체, 옵저버와 함께 사용하여 비동기 데이터 요청을 처리하고 UI를 업데이트할 수 있다. 쿼리가 가지는 속성

    > queryKey: 쿼리를 식별하는 고유한 키입니다.
    >
    > queryFn: 서버로부터 데이터를 가져오는 함수입니다.
    >
    > onSuccess, onError 등의 콜백 함수 등

## 제내릭과 제내릭 유틸리티

**제네릭이란 타입을 마치 함수의 파라미터처럼 사용하는 것**을 의미

```
function getText<T>(text: T): T {
  return text;
}
```

제네릭 기본 문법이 적용된 형태.
아래와 같이 함수 안에서 사용할 타입을 넘겨줄 수 있다.

```jsx
getText < string > 'hi';
getText < number > 10;
getText < boolean > true;
```

## 타입과 인터페이스 차이

-   객체 타입을 정의할 때도 사용할 수 있지만, 객체 타입을 정의할 때는 `interface`를 사용하는게 좋고,
-   단순한 **원시값(Primitive Type)**이나 **튜플(Tuple)**, **유니언(Union)** 타입을 선언할 때 `type`을 사용하는 것이 좋다.
-   type은 모든 타입을 선언할 때 사용할 수 있고, interface는 객체에 대한 타입을 선언할 때만 사용할 수 있다. 또한 확장 불가능한 타입을 선언하고 싶다면 type을 사용하면 되고, 확장 가능한 타입을 선언하고 싶다면 interface를 사용하면 된다.

## 서버사이트 렌더링 장점

## 장점

-   검색엔진 최적화 (SEO) 가능
    -   서버 사이드 렌더링을 통해 얻을 수 있는 가장 큰 장점
    -   검색 엔진 최적화란 구글, 네이버와 같은 검색 사이트에서 검색했을 때 결과가 사용자에게 많이 노출될 수 있도록 최적화 하는 기법
    -   특히, sns에서 링크를 공유했을 때 해당 웹 사이트의 정보를 이미지와 설명으로 표시해주는 OG(Open Graph) Tag를 페이지 별로 적용하기 위해서는 서버 사이드 렌더링이 효율적이다.
-   빠른 페이지 렌더링
    -   빈 HTML 페이지를 받아 브라우저에서 그리는 클라이언트 사이드 렌더링과 다르게 서버에서 미리 그려서 브라우저로 보내주기 때문에 페이지를 그리는 시간을 단축할 수 있다.
    -   즉, 클라이언트 사이드 렌더링보다 페이지 구성 속도는 느리지만 전체적으로 사용자에게 보여주는 컨텐츠 구성이 완료되는 시점은 빨라진다.

## 단점

-   프로젝트의 복잡도
-   서버 렌더링에 따른 부하가 발생
-   불필요한 인터넷 대역폭이 소모될 수 있음
-   **페이지 요청마다 페이지 새로고침이 발생한다.**

## 리엑트 컴포넌트 라이프 사이클

![리엑트 컴포넌트 라이프 싸이클.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/aee84880-96fd-4e10-90fc-a19384342fd0/dc8455fb-f99b-4375-842a-b3178170ac07/%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3_%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%91%E1%85%A9%E1%84%82%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3_%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%91%E1%85%B3_%E1%84%8A%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%86%AF.png)

컴포넌트는 생성(mounting) -> 업데이트(updating) -> 제거(unmounting)의 생명주기를 갖습니다.

리액트 클래스 컴포넌트는 라이프 사이클 메서드를 사용하고, 함수형 컴포넌트는 Hook을 사용합니다.
자세한 내용은 [[공식문서](https://ko.legacy.reactjs.org/docs/react-component.html)](https://ko.legacy.reactjs.org/docs/react-component.html)에 있습니다.

## 리엑트에서 스태이트와 프롭스 차이

-   두 객체 모두 렌더링 결과물에 영향을 주는 정보를 갖고 있는데, 한 가지 중요한 방식에서 차이가 있다.
-   props는 컴포넌트에 전달되는 반면, state는 컴포넌트 안에서 관리된다는 점
-   props는 변하지 않아야함

## 리엑트 컴포넌트의 데이터가 어떻게 전달되는지

## React는 왜 state를 동기적으로 업데이트 하지 않는 이유

---

React는 모든 컴포넌트가 자신의 이벤트 핸들러에서 setState()를 호출할 때 까지 리렌더링하지 않고 내부적으로 기다리고 있는다. 이를 통해 불필요한 리렌더링을 방지하며 성능을 향상시킨다.

### React가 이렇게 동작하는데는 중요한 이유가 2가지 존재한다.

-   props와 state 사이의 일관성을 해칠 수 있고, 이것은 디버깅하기 매우 힘든 이슈를 일으킬 수 있기 때문이다.
-   현재 작업 중인 새로운 기능들을 구현하기 힘들게 만들 수 있기 때문이다.

## setState()는 동기적으로 작동하나 비동기적으로 작동하나

---

setState가 비동기적으로 동작함으로 내부의 일관성을 보장하게 되는데,

state가 동기적으로 업데이트 되더라도 props는 그렇지 않다. 따라서 부모 컴포넌트가 리렌더링 될 때까지 자식 컴포넌트에서는 props를 알 수 없기 때문에 리렌더링이 일어나지 않고 이는 내부의 일관성을 해치게 된다.

또한, 비동기적으로 동작함으로써 setState() 내부에서 렌더링을 조정할 수 있다. 다른 페이지로 넘어갈 때 보통 스피너를 넣는 경우가 많은데 setState() 가 동기적으로 작동한다면 다른 페이지로 넘어가는 시간이 짧더라도 스피너는 항상 보여지게 된다. 이것은 유저 경험을 감소시킨다.

위와 같은 이유 때문에 setState()는 비동기적으로 작동하게 설계되어있다.

## 3. 불변성을 지켜야하는 이유는 무엇일까요?

---

state의 불변성을 지켜야하는 이유는 React에서 제공하는 setter함수인 setState를 사용하지 않게 되면, previous state가 오염되기 때문이다. 이전상태가 오염되게 되면 React는 이전 상태와 새로운 상태를 얕은 비교와 병합 하는 과정에 방해가 생기게 됩니다.

## **`useEffect` 내부에서 `setState` 해도 데이터가 바로 적용되지 않는 이유**

`useEffect` 내부에서 `setState`를 사용하면 컴포넌트 업데이트가 예상대로 일어나지 않을 수 있습니다. 이는 `useEffect`가 비동기적으로 실행되기 때문입니다.

### **1. 비동기 실행**

`useEffect`는 컴포넌트 렌더링 후 **별도의 작업 스케줄**에 등록됩니다. 즉, 컴포넌트 렌더링이 완료된 후 `useEffect` 콜백 함수가 실행됩니다.

따라서 `useEffect` 내부에서 `setState`를 사용하여 상태를 변경해도 컴포넌트는 **즉시 업데이트되지 않습니다**.

### **2. 컴포넌트 업데이트 순서**

`useEffect` 콜백 함수는 다음과 같은 순서로 실행됩니다.

1. **마운팅**: 컴포넌트가 처음 렌더링될 때
2. **업데이트**: 컴포넌트 props 또는 상태가 변경될 때
3. **클린업**: 컴포넌트가 언마운트될 때

`useEffect` 내부에서 `setState`를 사용하면 컴포넌트 상태가 변경되지만, **이미 렌더링 프로세스가 종료되었기 때문에 컴포넌트는 업데이트되지 않습니다**.

따라서 컴포넌트 업데이트를 위해서는 **다음 렌더링**까지 기다려야 합니다.

### **참고 사항**

-   `useEffect` 내부에서 `setState`를 사용하는 것은 일반적으로 권장하지 않습니다.
-   `useEffect` 내부에서 컴포넌트 상태를 변경해야 하는 경우 위에 설명된 방법 중 하나를 사용하십시오.
-   컴포넌트 업데이트 순서를 이해하는 것이 중요합니다.

## Prop Drilling이란 무엇일까?

Prop drilling은 React 애플리케이션에서 데이터를 전달하기 위해 필요한 과정을 설명하는 용어

이는 컴포넌트 트리에서 데이터를 하위 컴포넌트로 전달하기 위해 중간 컴포넌트를 통해 프로퍼티를 내려주는 것을 의미합니다.

이러한 중간 컴포넌트는 원하는 자식 컴포넌트에게 프로퍼티를 전달하기 위해 필요하지만 해당 값을 직접 사용하지 않는 경우에도 프로퍼티를 받고 전달해야 합니다.

Prop drilling의 장단점은 다음과 같습니다:

### 장점

1. **명시적인 값의 사용**:Prop drilling을 통해 값을 전달하는 방식은 어디서 데이터가 사용되는지 명확하게 보여줍니다. 각 컴포넌트에서 어떤 프로퍼티를 받아 사용하는지를 확인할 수 있어 코드의 의도를 더 명확하게 파악할 수 있습니다.
2. **값 추적 용이성**:Prop drilling을 사용하면 값의 흐름을 쉽게 추적할 수 있습니다. 값이 어떤 컴포넌트를 거쳐 전달되는지를 알 수 있으므로 버그를 디버깅하거나 코드를 변경할 때 더욱 편리합니다.
3. **코드 변경 파악 용이성**:Prop drilling을 통해 데이터가 전달되는 경로를 알 수 있기 때문에 코드 변경이 애플리케이션의 다른 부분에 어떤 영향을 주는지 파악하는 것이 용이합니다. 데이터의 흐름을 명확하게 파악할 수 있으므로 변경 사항에 따른 영향을 사전에 예측하고 관리할 수 있습니다.

### 단점

1. **프로퍼티 데이터 형식 변경의 불편함**:Prop drilling 데이터의 데이터 형식을 변경해야 하는 경우, 컴포넌트 계층 전체에서 업데이트하는 것이 어려울 수 있습니다.
2. **중간 컴포넌트에 불필요한 프로퍼티 전달**:컴포넌트 분리 과정에서 중간 컴포넌트를 통해 불필요한 프로퍼티가 전달될 수 있어 불필요한 복잡성을 초래할 수 있습니다.
3. **누락된 프로퍼티 인지의 어려움**:필요한 프로퍼티가 타겟 컴포넌트에 전달되지 않은 상황을 인지하기 어려울 수 있어 잠재적인 문제를 발견하기 어려울 수 있습니다.
4. **프로퍼티 이름 변경 추적의 어려움**:프로퍼티 이름이 계층에서 변경되면 해당 값을 추적하고 업데이트하는 것이 어려워질 수 있습니다.

## 참조

-   [[https://velog.io/@wlwl99/TypeScript-type과-interface의-차이](https://velog.io/@wlwl99/TypeScript-type%EA%B3%BC-interface%EC%9D%98-%EC%B0%A8%EC%9D%B4)](https://velog.io/@wlwl99/TypeScript-type%EA%B3%BC-interface%EC%9D%98-%EC%B0%A8%EC%9D%B4)
-   [[https://velog.io/@wkfwktka/서버-사이드-렌더링SSR과-클라이언트-사이드-렌더링CSR](https://velog.io/@wkfwktka/%EC%84%9C%EB%B2%84-%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81SSR%EA%B3%BC-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81CSR)](https://velog.io/@wkfwktka/%EC%84%9C%EB%B2%84-%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81SSR%EA%B3%BC-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81CSR)
-   https://ko.reactjs.org/docs/hooks-reference.html
-   LifeCycle Method - https://react.vlpt.us/basic/25-lifecycle.html
-   [React] 리액트의 생명주기와 Hook - [[https://velog.io/@sukong/REACT-리액트의-생명주기와-useEffect-Hook](https://velog.io/@sukong/REACT-%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%9D%98-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0%EC%99%80-useEffect-Hook)](https://velog.io/@sukong/REACT-%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%9D%98-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0%EC%99%80-useEffect-Hook)
-   [[https://velog.io/@kkojae91/리액트-적응기-state-props](https://velog.io/@kkojae91/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%A0%81%EC%9D%91%EA%B8%B0-state-props)](https://velog.io/@kkojae91/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%A0%81%EC%9D%91%EA%B8%B0-state-props)
-   https://velog.io/@rachel28/Prop-Drilling
