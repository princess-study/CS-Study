# 3월 3주차 모의 면접

# PWA

PWA는 웹과 네이티브 앱의 기능 모두의 이점을 갖도록 수 많은 특정 기술과 표준 패턴을 사용해 개발된 웹 앱

### Native App

- Android 또는 IOS같은 어떤 구체적인 플렛폼만을 위해 만들어진 응용 프로그램을 네이티브 앱이라고 함

### 하이브리드 앱

- 하이브리드 앱은 **네이티브 앱과 웹 앱의 개발 방식의 장점을 합친 앱**입니다.

## PWA의 기본 개념

- 웹과 모바일 앱의 장점을 결합한 접근 방식
- 빠른 로딩, 향상된 사용자 경험, 오프라인 접근성 제공

## PWA의 중요 구성 요소

### 서비스 워커

- 서비스 워커의 기능 및 역할
- 네트워크 요청을 가로채고 캐싱하여 오프라인 사용지원
- 앱 로딩 속도 향상 및 백그라운드 데이터 동기화

### 서비스 워커의 세부 기능

- 푸시 알림: 사용자 참여 증대를 위한 메시지 전송
- 오프라인 애셋 캐싱: 정적 자산을 브라우저 캐시에 저장하여 빠른 로딩 지원
- 매니페스트: 앱의 외관과 시작 설정 정의

## 2 매니페스트 파일

### 매니페스트 파일의 구성 및 중요성

- 앱 아이콘, 시작 화면, 배경 색상 등의 사용자 인터페이스 설정
- 사용자의 홈 화면에 앱 추가 기능 제공

### 매니페스트의 세부 설정

- 디스플레이 유형 (전체 화면, 스탠드얼론 등)
- 시작 URL 및 네비게이션 범위 설정

## CSR SSR 장단점

|  | CSR | SSR |
| --- | --- | --- |
| 장점 | - 화면 깜빡임이 없음- 초기 로딩 이후 구동 속도가 빠름- TTV와 TTI 사이 간극이 없음- 서버 부하 분산 | - 초기 구동 속도가 빠름- SEO에 유리 |
| 단점 | - 초기 로딩 속도가 느림- SEO에 불리 | - 화면 깜빡임이 있음- TTV와 TTI 사이 간극이 있음- 서버 부하가 있음 |

## CSR 과정

![다운로드 (1).png](https://prod-files-secure.s3.us-west-2.amazonaws.com/aee84880-96fd-4e10-90fc-a19384342fd0/5fafa9c2-70b9-4df6-aee9-ed83c5d4e367/%E1%84%83%E1%85%A1%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A9%E1%84%83%E1%85%B3_(1).png)

1. User가 Website 요청을 보냄.
2. CDN이 HTML 파일과 JS로 접근할 수 있는 링크를 클라이언트로 보낸다.
    CDN : aws의 cloudflare를 생각하면 됨. 엔드 유저의 요청에 '물리적'으로 가까운 서버에서 요청에 응답하는 방식
3. 클라이언트는 HTML과 JS를 다운로드 받는다.
    (이때 SSR과 달리 유저는 아무것도 볼 수 없다.)
4. 브라우저가 자바스크립트를 다운로드한다.
5. 다운이 완료된 JS가 실행된다. 데이터를 위한 API가 호출된다.
    (이때 유저들은 placeholder를 보게된다. )
6. 서버가 API로부터의 요청에 응답한다.
7. API로부터 받아온 data를 placeholder 자리에 넣어준다. 이제 페이지는 상호작용이 가능해진다.

출처:

https://hahahoho5915.tistory.com/52

[넌 잘하고 있어:티스토리]

## SSR

![다운로드 (2).png](https://prod-files-secure.s3.us-west-2.amazonaws.com/aee84880-96fd-4e10-90fc-a19384342fd0/88c2693d-043d-4363-aaad-8d28ab94ba81/%E1%84%83%E1%85%A1%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A9%E1%84%83%E1%85%B3_(2).png)

1. User가 Website 요청을 보냄.
2. Server는 'Ready to Render'. 즉, 즉시 렌더링 가능한 html파일을 만든다.    (리소스 체크, 컴파일 후 완성된 HTML 컨텐츠로 만든다.)
3. 클라이언트에 전달되는 순간, 이미 렌더링 준비가 되어있기 때문에 HTML은 즉시 렌더링 된다.    그러나 사이트 자체는 조작 불가능하다. (Javascript가 읽히기 전이다.)
4. 클라이언트가 자바스크립트를 다운받는다.
5. 다운 받아지고 있는 사이에 유저는 컨텐츠는 볼 수 있지만 사이트를 조작 할 수는 없다. 이때의 사용자 조작을 기억하고 있는다.
6. 브라우저가 Javascript 프레임워크를 실행한다.
7. JS까지 성공적으로 컴파일 되었기 때문에 기억하고 있던 사용자 조작이 실행되고 이제 웹 페이지는 상호작용 가능해진다.

출처:

https://hahahoho5915.tistory.com/52

[넌 잘하고 있어:티스토리]

# JWT

WT(Json Web Token)은 **Json 객체에 인증에 필요한 정보들을 담은 후 비밀키로 서명한 토큰**으로, 인터넷 표준 인증 방식

## 인증과 인가

**시스템의 자원을 적절하고 유효한 사용자에게 전달하고 공개하는 방법**

- 인증: 클라이언트가 자기자신이라고 주장하고 있는 사용자가 맞는지를 검증하는 과정
- 인가: 인증 작업 이후에 행해지는 작업으로 인증된 사용자에 대한 자원에 대한 접근 확인 절차를 의미

## 엑세스 토큰과 리프레시 토큰이 분리되어 있는 이유

클라이언트와 서버 간의 API 통신 중, **토큰이 털릴 수 있기 때문**이다.

그래서 직접 API를 호출하는 엑세스 토큰의 주기는 짧게 하고, (약 1시간)

엑세스 토큰을 재발급하는 리프레시 토큰의 주기는 비교적 길게 한다. (약 2주)

이런식으로 진행하면 엑세스 토큰이 털리더라도 만료 주기가 짧기 때문에 피해를 조금이나마 줄일 수 있다.

## 세션 기반 인증

세션기반 인가는 사용자의 인증 정보가 서버의 세션 저장소에 저장되는 방식이다. 사용자가 로그인을 하면, 해당 인증 정보를 서버의 세션 저장소에 저장하고, 사용자에게는 저장된 세션 정보의 식별자인 Session ID를 발급한다. 발급된 Session ID는 브라우저에 쿠키 형태로 저장되지만, 실제 인증 정보는 서버에 저장되어 있다.

브라우저는 인증 절차를 마친 이후의 요청마다 HTTP Cookie 헤더에 Session ID 를 함께 서버로 전송한다. 서버는 요청을 전달받고, Session ID에 해당하는 세션 정보가 세션 저장소에 존재한다면 해당 사용자를 인증된 사용자로 판단한다.

## **토큰기반 인증**

세션 기반 인증이 인증 정보를 서버에 저장하는 방식이라면, 토큰 기반 인증은 인증 정보를 클라이언트가 직접 들고 있는 방식이다. 이때 인증 정보가 토큰의 형태로 브라우저의 로컬 스토리지(혹은 쿠키)에 저장된다. 토큰의 종류에 따라 다르겠지만, 대표적인 토큰인 JWT의 경우 디지털 서명이 존재해 토큰의 내용이 위변조 되었는지 서버측에서 확인할 수 있다.

토큰 기반 인증에서는 사용자가 가지고 있는 토큰을 HTTP 의 Authorization 헤더에 실어 보낸다. 이 헤더를 수신한 서버는 토큰이 위변조 되었거나, 만료 시각이 지나지 않은지 확인한 이후 토큰에 담겨있는 사용자 인증 정보를 확인해 사용자를 인가한다.

![다운로드 (3).png](https://prod-files-secure.s3.us-west-2.amazonaws.com/aee84880-96fd-4e10-90fc-a19384342fd0/c9881908-263d-476e-9fc9-6283388f8308/%E1%84%83%E1%85%A1%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%85%E1%85%A9%E1%84%83%E1%85%B3_(3).png)

# 복잡도: 시간 복잡도와 공간 복잡도, 빅오 표기법

### 복잡도

- 알고리즘의 성능, 효율성을 나타내는 척도
- 크게 시간 복잡도(Time Complexity)와 공간 복잡도(Space Complexity)로 나눌 수 있다.
- 각 알고리즘이 주어진 특정 크기의 입력(n)을 기준으로 수행시간(연산) 혹은 사용공간이 얼마나 되는지 객관적으로 비교할 수 있는 기준을 제시한다.
- 복잡도를 나타내는 방법으로는 점근 표기법으로 O(빅오), Ω(오메가), Θ(세타) 등이 있고, 주로 빅오와 세타 표기법이 많이 사용된다.

> 어떤 알고리즘이 효율적인지를 판단하는 척도
> 

## 시간복잡도와 공간복잡도란?

- 시간복잡도: 알고리즘이 문제를 해결하기 위해 필요한 시간을 나타내는 척도입니다. 이를 통해 데이터 크기에 따른 알고리즘의 실행 시간 증가율을 대략적으로 예측할 수 있습니다. 시간복잡도는 종종 Big O 표기법으로 표현되며, 주로 입력 크기에 따른 최악의 경우를 기준으로 합니다.
- 공간복잡도: 알고리즘이 문제를 해결하는 데 필요한 메모리 양을 나타내는 척도입니다. 시간복잡도와 마찬가지로 Big O 표기법으로 표현되며, 필요한 저장 공간의 증가율을 예측하는 데 사용됩니다.

## 빅오 표기법 (Big-O notation)

빅오 표기법(Big-O notation)은 복잡도를 나타내는 점근 표기법 중 가장 많이 사용되는 표기법이다.

가장 많이 사용되는 이유는 알고리즘 효율성을 **상한선 기준**으로 표기하기 때문이다.

다시 말해 **최악의 경우**를 고려하는 데 가장 좋은 표기법

출처: https://kindjjee.tistory.com/139

# SPA MPA

# SPA

- SPA(Single Page Application)는 한 개(Single)의 Page로 구성된 Application이다.

# MPA

- 여러 개(Single)의 Page로 구성된 Application이다.
- MPA는 SSR(Server Side Application) 방식으로 렌더링한다.

## MPA 장점

SEO 관점에서 유리하다.
    ◦ MPA는 완성된 형태의 HTML 파일을 서버로부터 전달받는다.따라서 검색엔진이 페이지를 크롤링하기에 적합하다.

첫 로딩 매우 짧다.

◦ 서버에서 이미 렌더링해 가져오기 때문이다.
    ◦ 그러나 클라이언트가 JS 파일을 모두 다운로드하고 적용하기전 까지는 각각의 기능은 동작하지않는다.

## MPA 단점

새로운 페이지를 이동하면 ‘깜빡’인다. (UX)
    ◦ 매 페이지 요청마다 리로딩(새로고침) 발생.새로운 페이지를 요청할 때마다 전체 페이지를 다시 렌더링하기 때문이다.페이지 이동시 불필요한 템플릿도 중복해서 로딩 (성능)서버 렌더링에 따른 부하모바일 앱 개발시 추가적인 백엔드 작업 필요 (생산성)개발이 복잡해질 수 있다.

## SPA 장점

자연스러운 사용자 경험 (UX)
    ◦ 전체 페이지를 업데이트 할 필요가 없기 때문에 빠르고 ‘깜빡’ 거림이 없다.필요한 리소스만 부분적으로 로딩 (성능)
    ◦ SPA의 Application은 서버에게 정적리소스를 한 번만 요청한다.그리고 받은 데이터는 전부 저장해놓는다. (캐시=Cache)서버의 템플릿 연산을 클라이언트로 분산 (성능)컴포넌트별 개발 용이 (생산성)모바일 앱 개발을 염두에 둔다면 동일한 API를 사용하도록 설계 가능 (생산성)

## SPA 단점

JavaScript 파일을 번들링해서 한 번에 받기 때문에 초기 구동 속도가 느리다. (Webpack의 code splitting으로 해결 가능)검색엔진최적화(SEO)가 어려움 (SSR로 해결 가능)보안 이슈 (프론트엔드에 비즈니스 로직 최소화)
    ◦ SSR에서는 사용자에 대한 정보를 서버측에서 세션으로 관리를 하지만 CSR 방식에서는 클라이언트측의 쿠키말고는 사용자에 대한 정보를 저장할 공간이 마땅치 않다.

### 참조

- https://hahahoho5915.tistory.com/52
- https://velog.io/@welloff_jj/Complexity-and-Big-O-notation
- https://dev.to/thecodearcher/what-really-is-the-difference-between-session-and-token-based-authentication-2o39
- https://hudi.blog/session-based-auth-vs-token-based-auth/
- https://kindjjee.tistory.com/139
- [https://hanamon.kr/spa-mpa-ssr-csr-장단점-뜻정리/](https://hanamon.kr/spa-mpa-ssr-csr-%EC%9E%A5%EB%8B%A8%EC%A0%90-%EB%9C%BB%EC%A0%95%EB%A6%AC/)
- [https://velog.io/@theon2/기술면접-예상질문-알고리즘](https://velog.io/@theon2/%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EC%98%88%EC%83%81%EC%A7%88%EB%AC%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
- https://hahahoho5915.tistory.com/52