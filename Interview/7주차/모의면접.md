# 파이널 모의 면접 질문

# 브라우저 렌더링

1. 요청 :브라우저 -> 서버에 요청 : 서버에 필요한 리소스를 요청
2. 트리 생성 :브라우저의 렌더링 엔진-> HTML,CSS => DOM+CSSOM =랜더 트리 생성
3. Layout :브라우저의 자바스크립트 엔진 -> JS는 => DOM API사용해 랜더 트리 변경, 리플로우 리페인트
4. 페인팅(repaint) :실제 그리기렌더 트리를 기반으로 HTML요소의 레이아웃 계산, HTML요소 페인팅

# 리플로우 리페인트 실행되는 시점

### (1) **리플로우 (reflow)**

- 리플로우는 요소의 너비, 높이, 위치 등이 변경되어 렌더트리를 재생성하는 작업이다.

> 📌 리플로우 발생 시점
> 
> 
> a. DOM 요소의 기하학적 속성이 변경될때 (width, height 등)
> 
> b. 브라우저 사이즈가 변할때
> 
- 리플로우는 비용이 큰 작업인데, 그 이유는 특정 요소에서 리플로우가 발생하면 주변 요소(*부모, 자식, 형제*)에도 영향을 주기 때문이다.

### **(2) 리페인트 (repaint)**

- 변경된 요소를 화면에 그려주는 작업을 리페인트라고 한다.

> 📌 리페인트 발생 시점
> 
> 
> a. 리플루우가 발생했을 때
> 
> b. 요소의 스타일(색상, 배경색 등)이 변경되었을 때
> 
> c. visibility: hidden ↔ visble로 변경될 때
> 
- 리페인트는 요소의 스타일이 변경되었을 때 발생하므로 리플로우보다 비용이 적다.

# 호이스팅이란

**인터프리터가 코드를 실행하기 전에 함수, 변수, 클래스 또는 임포트(import)의 선언문을 해당 범위의 맨 위로 끌어올리는 것처럼 보이는 현상**

# 현재는 let const를 사용하는데 var를 알아야 하는 이유?

이전에  작성된 코드들을 수정할 경우가 있을 수도 있음 `var`를 사용하는 오래된 스크립트를 `let`로 바꿀 때 `var`에 대해 제대로 알아두지 못하면 예상치 못한 에러를 만날 수 있기 때문에

`var`로 선언한 변수는 `let`이나 `const`로 선언한 변수와 다른 두 가지 주요한 특성을 보입니다.

1. `var`로 선언한 변수는 블록 스코프가 아닌 함수 수준 스코프를 갖습니다.
2. `var` 선언은 함수가 시작되는 시점(전역 공간에선 스크립트가 시작되는 시점)에서 처리됩니다.

`var`만의 특성은 대부분의 상황에서 좋지 않은 부작용을 만들어냅니다. `let`이 표준에 도입 이유가 바로 이런 부작용을 없애기 위해서입니다. 변수는 블록 레벨 스코프를 갖는 게 좋으므로 이제는 `let`과 `const`를 이용해 변수를 선언하는 게 대세가 되었다.

# TDZ
![다운로드](https://github.com/princess-study/CS-Study/assets/133184988/5516e17d-1d40-4392-9669-ae4fa9a8c7ce)



let으로 선언된 변수는 var 키워드와는 다르게 선언단계와 초기화 단계가 분리되어서 진행이 됩니다.

그렇기 때문에 실행 컨텍스트에 변수를 등록했지만,

메모리가 할당이 되질 않아 접근할 수 없어 참조 에러(ReferenceError)가 발생하는데

이때의 이 구간(스코프의 시작 지점부터 초기화 시작 지점까지의 구간)을  TDZ라 한다.

# 소영

건우: 이터러블과 유사배열 차이 

`for..of`을 사용할 수 있는 객체를 *이터러블*이라고 부릅니다.

인덱스와 `length` 프로퍼티가 있는 객체는 *유사 배열*이라 불립니다. 유사 배열 객체엔 다양한 프로퍼티와 메서드가 있을 수 있는데 배열 내장 메서드는 없습니다.

# 프로토타입이란?

javaScript는 Java와 다르게 클래스가 없는, 프로토타입 기반 언어입니다. 자바스크립트의 모든 객체는 최소한 하나 이상의 다른 객체로부터 상속을 받으며, 이때 **상속되는 정보를 제공하는 객체**를 프로토타입(prototype)이라고 합니다.

# 자바스크립트가 코드의 환경과 순서를 보장할 수 있는 이유와 원리를 설명해주세요

## 실행 컨텍스트

> 실행할 코드에 제공할 환경 정보들을 모아놓은 객체
> 
- 자바스크립트는 동일한 환경에 있는 환경 정보들을 모은 실행 컨텍스트를 콜스택에 쌓아올린 후 실행하여 코드의 환경과 순서를 보장할 수 있게 됩니다.
- 자바스크립트는 렉시컬스코프를 따르기때문에 **함수는 태어나자마자 상위 스코프가 결정**이 되고 이후에 **함수객체가 생성이 되면 해당함수객체는 본인의 상위 스코프를 항상 알 수 있게 된다.**

# 결론

- ***식별자와 스코프는 실행 컨텍스트의 렉시컬 환경으로 관리하고 코드 실행 순서는 실행 컨텍스트 스택으로 관리한다.***

건우님

# 실행 컨텍스트와 클로저

- 함수가 선언된 환경의 스코프를 기억하여 함수가 스코프 밖에서 실행될 때에도기억한 스코프에 접근할 수 있게 만드는 문법을 말한다.
- 클로저는 실행 컨텍스트의 변수 환경(Variable object, 변수 객체)를 가리키며, 이는해당 실행 컨텍스트가 Call Stack에서 제거되었더라도 변수 환경(Variable object, 변수 객체)를 가리킨다.
- 클로저는 해당 상위 함수가 리턴된 이후에도 상위 함수의 모든 변수에 대해 접근이 가능하다. 또한 외부 범위에 대한 참조를 유지하므로스코프 체인이 보존되어 상위 스코프에 접근할 수 있다.
- 클로저는 반환된 내부 함수가자신이 선언되었을 때의 환경(렉시컬 환경)인 스코프를 기억하며스코프(자신이 선언되었을 때의 환경) 밖에서 호출되어도 언제나 그 환경(스코프)에 접근할 수 있다.
- 클로저는 자신이 생성될 때의 환경(렉시컬 환경)을 기억한다.
- 클로저는 내부 함수가 유효한 상태에서 외부 함수가 종료하여 외부 함수의 실행 컨텍스트가 반환되어도 외부 함수 실행 컨텍스트 내의활성 객체(Activation object)는 내부 함수에 의해 참조되는 한 유효하여 내부 함수가 스코프 체인을 통해 참조할 수 있는 것을 의미한다.

# 클로저 사용 이유

> 상태를 안전하게 변경하고 유지하기 위해 사용한다.
> 

다시말해, 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.