# 자바스크립트를 주로 사용하는 웹 사이트에서는 어떻게 한번에 여러 요청을 받을까? 그리고 여러 요청이 오갈 수 있는 자바스크립트는 왜 싱글 쓰레드일까? 

## 비동기 프로그래밍
동기 처리 : 현재 실행 중인 테스크가 종료할 때까지 다음에 실행될 테스크가 대기하는 방식 - 실행 순서가 보장되는 이점 but 이전 테스크가 종료할 때까지 이후 태스크들이 블로킹된다는 단점

비동기 처리: 현재 실행중인 테스크가 종료 되지 않은 상태여도 다음 태스크를 실행하는 방식 - 동기 처리의 장점이 단점 단점이 장점

- 타이머 , HTTP 요청, 이벤트 핸들러는 비동기 처리 방식으로 동작

함수가 실행되려면 “함수 코드 평가 과정”에서 생성된 함수 실행 컨텍스트가 실행 컨텍스트 스택에 푸시되어야함

- 실행 컨텍스트 스택에 함수 실행 컨텍스트 푸시 === 함수 실행의 시작

함수 실행 순서는 실행 컨텍스트 스택으로 관리

## 자바스크립트는 싱글 스레드 언어.

> 자바스크립트는 java, python과 다르게 멀티 스레드를 지원하지 않는 싱글 스레드 언어이다.
> 

이게 무슨말이냐…

동시에 2개 이상의 함수를 실행할 수 없다는 것을 의미한다.

## 싱글 스레드 방식

실행 컨텍스트 스택의 최상위 요소인 태스크들은 현재 실행 중인 실행 컨텍스트가 pop되어 실행 컨텍스트 스택에서 제거되면(현재 실행중인 함수가 종료되면) 실행되기 때문이다. 이 방식을 **싱글 스레드** 방식이라고 한다. 우선 싱글 스레드 예제를 봐보자

```jsx
// sleep 함수는 일정 시간(delay)이 경과한 이후에 콜백 함수(func)를 호출
    function sleep(func, delay) {
        // Date.now()는 현재 시간을 숫자(ms)로 반환
        const delayUntil = Date.now() + delay;
        // 현재 시간에 delay를 더한 delatuntill이 현재 시간보다 작으면 계속 반복
        while (Date.now() < delayUntil);
        // 일정 시간 경과 이후 콜백 함수 호출
        func();
    }

    function foo(){
        console.log('foo')
    }

    function bar() {
        console.log('bar')
    }

    sleep(foo, 3 * 1000);
    // bar 함수는 sleep함수의 실행이 종료된 이후에 호출되므로 3초 이상 블로킹됨
    bar(); foo // 호출 -> bar 호출
```

위 코드는 3로 추에 foo가 호출되고 그 다음 bar가 호출된다. 이때 sleep 함수의 실행이 종료된 이후에 호출되므로 3초 이상(foo 함수 실행 시간 + 3초) 호출되지 못하고 블로킹(작업 중단)된다. === 현재 실행중인 태스크가 종료할 때까지 다음에 실행될 태스크가 대기한다.

## 싱글 스레드시 발생하는 문제

만약 많이 무거운 작업을 싱글 스레드 방식으로 수행한다면 그 뒤의 어떤 작업도 진행되지 않기에, 화면 로딩, 통신 연결 등의 비효율을 높이고, 사용성 또한 급격히 떨어진다. 그리고 오늘날같이 엄청나게 많은 이미지와, 엄청나게 많은 데이터를 갖고 있는 웹페이지를 실행시킬 때 이러한 엄청 큰 문제가 발생한다.

## 비동기

```jsx
function foo(){
	console.log('foo');
}

function bar(){
	console.log('bar');
}

setTimeout(foo, 3 * 1000);
bar();

// 동작
// bar 호출 => (3초 후) foo 호출
// ??? bar가 나중에 실행되어야 하는거 아닌가? => 먼저 실행된 타이머가 종료되지 않은
// 상태에서 다음 태스크가 실행되었다는 증거
```

위 코드는 동기 처리 예제 코드의 sleep 함수와 유사하게 일정 시간이 지나면 콜백 함수를 호출하는데  setTimeout 함수 이후의 태스크를 블로킹(작업 중단)하지 않고 곧바로 실행한다.  현재 실행중인 태스크가 종료되지 않은 상태에서 다음 태스크를 실행하는 방식 === 비동기 처리

비동기 처리를 수행하는 비동기 함수는 전통적으로 콜백 패턴을 사용

- 비동기 처리를 위한 콜백 패턴을 콜백 헬을 발생시켜 가독성을 나쁘게함
- 비동기 처리중 발생한 에러의 예외 처리가 곤란하다.
- 여러 개의 비동기 처리를 한번에 처리하는데 한계가 있다

위 문제 해결을 프로미스로 해결

결론 : 멀티 스레딩은 비동기 프로그래밍의 한 형태이다.

## 이벤트 루프와 태스크 큐

### setTimeout과 같은 비동기 방식 동작 방법

아까 자바스크립트의 특징 중 하나는 싱글 스레드로 동작한다인데 브라우저가 동작하는 것을 보면 여러가지 태스크가 동시에 처리되는 것처럼 느껴질것이다.

ex> 애니메이션 효과를 통해 움직이면서 이벤트 처리, HTTP 요청을 통한 데이터 가져오기 처럼 동시성을 지원하는데 이게 ***이벤트 루프***다.

> 이벤트 루프는 브라우저에 내장되어 있는 기능 중 하나
> 

![IMG_0237.HEIC](https://prod-files-secure.s3.us-west-2.amazonaws.com/aee84880-96fd-4e10-90fc-a19384342fd0/563ace97-2c3a-4506-b116-4005a017240a/IMG_0237.heic)

위 그림은 브라우저 환경을 그림으로 표현한 것이다.  대부분의 자바스크립트 엔진은 크게 콜 스택과 힙 2개의 영역으로 구분할 수 있다.

- 콜 스택: 소스 코드(전역  코드나 함수 코드 등)평가 과정에서 생성된 실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행 컨텍스트 스택이 바로 콜 스택이다.
    - 함수 호출시 실행 컨텍스트가 순차적으로 콜 스택에 푸시되어 순차적으로 실행 자바스크립트는 하나의 싱글 스레드라 최상위 실행 컨텍스트가 종료되어 콜 스택에서 제거되기 전까지는 다른 어떤 테스크도 실행되지 않는다.
- 힙 : 객체가 저장되는 메모리 공간, 콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 참조한다.
    - 메모리에 값을 저장하려면 먼저 값을 저장할 메모리 공간의 크기를 결정해야함 객체는 원시 값과는 달리 크기가 정해져 있지 않으므로 할당해야 할 메모리 공간의 크기를 런타임에 결정(동적 할당)해야 한다. 따라서 객체가 저장되는 메모리 공간인 힙은 구조화되어 있지 않다는 특징이 있다.

**콜스택과 힙으로 구성된 자바스크립트 엔진은 단순히 태스크가 요청되면 콜 스택을 통해 요청된 작업을 순차적으로 실행할 뿐임, 비동기 처리에서 소스코드의 평가와 실행을 제외한 모든 처리는 자바스크립트 엔진을 구동하는 환경인 브라우저 또는 Node.js가 담당함**

- ex) 비동기 방식으로 동작하는 setTimeout의 콜백 함수의 평가와 실행은 자바스크립트 엔진이 담당하지만 호출 스케줄링을 위한 타이머 설정과 콜백 함수의 등록은 브라우저 또는 Node.js가 담당한다. 이를 위해 브라우저 환경은 테스크 큐와 이벤트 루프를 제공한다.

### 태스크 큐

- setTimeout이나 setInterval과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역, 태스크 큐와는 별도로 프로미스의 후속 처리 메서드의 콜백 함수가 일시적으로 보관되는 마이크로태스크 큐도 존재한다.

### 이벤트 루프

- 이벤트 루프는 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 그리고 태스크 큐에 대기중인 함수(콜백 함수, 이벤트 핸들러 등)가 있는지 반복해서 확인한다. ***만약 콜 스택이 비어있고 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적으로 태스크 큐에 대기중인 함수를 콜 스택으로 이동시킨다.*** 이떄 콜 스택으로 이동한 함수는 실행된다. 즉 태스크 큐에 일시 보관된 함수들은 비동기 처리 방식으로 동작한다.

```jsx
function foo(){
	console.log('foo');
}

function bar(){
	console.log('bar');
}

setTimeout(foo, 3 * 1000);
bar();

// 동작
// bar 호출 => (3초 후) foo 호출
// ??? bar가 나중에 실행되어야 하는거 아닌가? => 먼저 실행된 타이머가 종료되지 않은
// 상태에서 다음 태스크가 실행되었다는 증거
```

그래서 이러한 비동기 작업을 자세히 파헤쳐보자

1. 전역 코드 평가 ⇒ 전역 실행 컨텍스트 생성 및 콜 스택에 푸시
2. 전역 코드 실행 ⇒ setTimeout 호출 이때 setTimeout 함수 실행 컨텍스트 생성되고 콜 스택에 푸시되어 현재 실행 중인 실행 컨텍스트가 된다. 브라우저의 Wep API인 타이머 함수도 함수이므로 함수 실행 컨텍스트를 생성한다.
3. setTimeout 함수가 실행되면 콜백 함수를 타이머 설정과 타이머가 만료되면 콜백 함수를 태스크 큐에 푸시하는것(호출 스케줄링 )은 브라우저 역할이다.
    - 호출 스케줄링 : 일정 시간이 지난 후에 원하는 함수를 예약 실행(호출)할 수 있게 하는 것
4. ***브라우저가 수행하는 4-a과 자바스크립트 엔진이 수행하는 4-b는 병행 처리***된다.
    1. 브라우저는 타이머를 설정하고 만료를 기다리다 만료되면 콜백 함수 foo가 태스크 큐에 푸시됨 (setTimeout의 지연 시간을 0으로 설정하면 최소 지연시간인 4ms가 설정된다.) 따라서 4ms 후에 콜백 함수 foo가 태스크 큐에 푸시되어 대기하게 된다. 이 처리 또한 자바스크립트 엔진이 아니라 브라우저가 수행한다. 이처럼 setTimeout 함수로 호출 스케줄링한 콜백 함수는 정확히 지연시간 후에 호출된다는 보장은 없다. 지연 시간 이후에 콜백 함수가 태스크 큐에 푸시되어 대기하게 되지만 콜 스택이 비워야 호출되므로 시간차가 발생할 수 있기 때문이다.
    2. bar 함수가 호출되어 bar 함수의 실행 컨텍스트가 생성되고 콜 스택에 푸시되어 현재 실행 중인 실행 컨텍스트가 된다. 이후 bar 함수가 종료되어 콜 스택에서 pop된다. 이때 브라우저가 타이머를 설정한 후 4ms가 경과했다면 foo 함수는 아직 태스크 큐에서 대기중이다.
5. 전역 코드 실행이 종료되고 전역 실행 컨텍스트가 콜 스택에서 팝된다. 이로서 콜스택에는 아무런 실행 컨텍스트도 존재하지 않게 된다.
6. 이벤트 루프에 의해 콜 스택이 비어 있음이 감지되고 태스크 큐에서 대기중인 콜백 함수 foo가 이벤트 루프에 의해 콜 스택에 푸시된다. 다시 말해. 콜백 함수 foo의 함수 실행 컨텍스트가 생성되고 콜 스택에 푸시되어 현재 실행 중인 실행 컨텍스트가 된다 이후 foo 함수가 종료되어 콜스텍에서 pop된다.

## 야 근디 비동기랑 멀티 스레딩 차이가 뭐여 둘이 똑같은거 아녀?

### 비동기 vs 멀티스레딩

멀티 스레딩: 은 여러 다른 함수들을 동시에 실행하는 것

비동기 프로그래밍 : 여러 함수들이 non-blocking으로 실행되는 것

- 비동기적이라는 것은 단일 스레드 멀티 스레드 모두에게 적용 가능하다.

결론 : 멀티 스레딩은 비동기 프로그래밍의 한 형태이다.

## 아니 근데 자바스크립트는 왜 멀티스레드로 안하고 왜 싱글 스레드로 하는거여?

자자 고수님 도움을 받자면

### 인터넷 블로그 1: 자바스크립트가 싱글스레드를 사용함으로써 얻는 이점은 바로 동시성 문제를 신경쓰지 않아도 된다는 것

> 그 예시로 iOS나 Android같이 멀티스레드 환경을 제공함에도 항상 주의사항이 따라붙는데, UI 스레드(메인 스레드) 이외의 다른 Worker 스레드에서는 UI 작업을 하지 말아야 한다는 것입니다.
> 
> 
> 사용자에게 있어서 화면이라는 자원에 여러 스레드가 동시에 접근하게 된다면 문제가 발생할 여지가 생기게 됩니다.
> 
> 만약 같은 부분에 대해서 서로 다른 수정을 요구한다면, 우리가 생각한 대로 수정이 될 것이라는 보장을 하기 어려워지게된다.
> 
> 이런 위험성을 차단하기 위한 목적과 함께, 멀티스레드로 얻을 수 있는 이득이 싱글스레드를 유지하는 것보다 크지 않기 때문에 JavaScript는 싱글스레드를 사용한다고 추측할 수 있겠습니다.
> 

### 또다른 블로그: 쉬워서

> 이유는 바로 **쉬워서**이다. 만약 자바스크립트가 멀티 쓰레드로 실행되는 언어였다면 웹페이지에서 발생하는 동시성 문제에 대해 해결해야 했다. 실제로 멀티 쓰레드로 구현된 서비스에서는 이 동시성 문제에 대해 정말 많은 신경을 쓴다. 하지만 자바스크립트는 단일 쓰레드로 실행되므로 인해 교착 상태와 같은 다중 쓰레드 환경에서 발생할 수 있는 복잡한 시나리오를 신경 쓸 필요가 없으며 비동기 처리를 통해 쉽게 여러 요청을 처리할 수 있다.
> 

위 둘이 같은 말 입니다.

### 자자 혹시 몰라서 지피티 형에게도 물어보았습니다.

> JavaScript는 일반적으로 단일 스레드 환경에서 작동합니다. 즉, 주로 원본과 디자인 목표로 인해 한 번에 하나의 작업을 실행합니다. 여기에는 몇 가지 이유가 있습니다.
> 
> 1. **단순성과 일관성**: JavaScript는 처음에 웹 브라우저용 경량 스크립트 언어로 설계되었습니다. 단일 스레딩은 언어를 단순화하고 다양한 플랫폼과 환경에서 일관되게 배우고 사용하기를 더 쉽게 만듭니다.
> 2. **동시성 모델**: JavaScript는 이벤트 루프라고 알려진 이벤트 기반 동시성 모델에서 작동합니다. 이 모델을 사용하면 멀티스레딩 없이도 비동기 작업을 효율적으로 처리할 수 있습니다. 네트워크 요청이나 파일 I/O와 같은 비동기 작업을 시작할 수 있으며 JavaScript 엔진은 이러한 작업이 완료될 때까지 기다리는 동안 다른 코드를 계속 실행할 수 있습니다.
> 3. **DOM 조작**: JavaScript는 웹 브라우저에서 DOM(문서 개체 모델)을 조작하는 데 크게 관여합니다. 여러 스레드에서 DOM 조작을 수행하면 경쟁 조건 및 동기화 문제가 발생하여 잠재적으로 UI에 불일치가 발생할 수 있습니다.
> 4. **메모리 관리**: 멀티스레딩은 공유 메모리 및 잠금 및 뮤텍스와 같은 동기화 기본 요소를 처리하는 등 메모리 관리에 복잡성을 가져옵니다. 단일 스레드 JavaScript는 이러한 복잡성을 처리할 필요가 없으므로 메모리 관리를 단순화합니다.
> 5. **보안 문제**: 멀티스레딩을 도입하면 경쟁 조건 및 교착 상태와 같은 보안 취약점이 노출되는 영역이 잠재적으로 늘어날 수 있습니다. 단일 스레드 실행은 이러한 문제의 위험을 줄여줍니다.
> 
> JavaScript 자체는 단일 스레드이지만 최신 웹 브라우저는 네트워크 요청 처리, UI 렌더링, Web Worker 및 WebGL과 같은 기술을 통한 과도한 계산 실행과 같은 다른 영역에서 멀티스레딩을 활용합니다. 
> 

# **결론 : 자바스크립트는 정말 싱글 쓰레드일까?**

맞다, 정확하게 말하면 자바스크립트의 메인 쓰레드인 이벤트 루프가 싱글 쓰레드이기 때문에 자바스크립트를 싱글 쓰레드 언어라고 부른다. 하지만 ***이벤트 루프만 독립적으로 실행되지 않고 웹 브라우저나 NodeJS같은 멀티 쓰레드 환경에서 실행된다. 즉, 자바스크립트 자체는 싱글 쓰레드가 맞지만 자바스크립트 런타임은 싱글 쓰레드가 아니다.***

자바스크립트는 웹 브라우저에서 실행되는 스크립트 언어이다. 자바스크립트는 웹 브라우저 뿐만 아니라 다양한 환경에서 실행 가능 이떄 코드가 실행되는 환경을 런타임이라고 한다.

## 참조

- 모던 자바스크립트 딥 다이브
- https://ssocoit.tistory.com/269
- https://jayhyun-hwang.github.io/2021/09/02/The-Difference-Between-Asynchronous-And-Multi-Threading/
- https://chanyeong.com/blog/post/44