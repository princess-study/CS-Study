# 브라우저 렌더링

브라우저가 화면에 나타나는 요소를 렌더링하는 방법: 렌더링엔진 사용⇒ HTML, CSS, 자바스크립트로 렌더링할때 CRP 라는 프로세스 사용

## 단계

1.HTML, CSS,자바스크립트, 이미지 폰트 파일등 렌더링에 필요한 리소스를 요청⇒ 서버로부터 응답 받음

1. 서버로부터 응답된 HTML과 CSS 파싱 
    - HTML 파싱 후 DOM 트리 구축
    - CSS 파싱 후 CSSOM 트리 구축
      
2. Javascript 실행 
- HTML 중간에 스크립트가 있다면 HTML 파싱이 중단됨 (DOM 생성과정을 중단시킬 수 있음. HTML 문서 내에서 <script> 태그를 만나면 해당 스크립트가 실행되기 전까지 HTML 파싱이 중단되는데, 스크립트가 DOM노드에 접근하거나 변경할 수 있기 때문에 발생함. async 와 defer속성을 사용한 스크립트 태그는 파싱 중단을 관리 가능. src어트리뷰트를통해 외부 자바스크립트 파일을 로드하는 경우에만 사용 가능하다. )
- 브라우저는 동기적으로 파싱하고 실행하기때문에 script의 위치에 따라 DOM생성이 블로킹되어 지연될 수 있다는것을 의미 (script태그의 위치 중요) ⇒ body요소의 가장아래에 위치시키는것이 좋다.

```jsx
<script async src="extern.js"></script>
```

HTML 파싱 + 외부자바스크립트 파일의 로드가 비동기적으로 동시에 진행됨. 

async 와 defer어트리뷰트는 자바스크립트의 실행 시점에 차이가 있음

async

- 자바스크립트의 파싱과  실행이 *자바스크립트 파일의 로드가 완료된 직후* 진행되고, 이때 HTML파싱이 중단됨.
- 태그의 순서와는 상관없이 로드가 완료된 자바스크립트부터 실행됨 ⇒ 순서가 보장되지 않음

defer 

- 자바스크립트의 파싱과 실행이*HTML파싱이 완료된 직후,DOM 생성이 완료된 직후 실행됨. 
⇒DOM 생성이 완료된 이후 실행되어야할때 유용*

1. DOM 과 CSSOM을 조합하여 렌더트리를 구축 
- 렌더 트리는 화면에 실제로 표시되어야 하는 요소들로만 구성됨
    - display:none 속성과 같이 화면에서 보이지도 않고 공간을 차지하지도 않는 것은 렌더트리로 구축되지 않음
    - visibility:hidden은 보이지 않지만, 공간은 차지하므로 렌더 트리에 포함됨.
1. Layout 단계: 뷰포트 기반으로 렌더트리의 각 노드가 가지는 정확한 위치와 크기를 계산. 
    - 뷰포트 내에서 각 요소가 어디에 위치해야하는지, 크기가 얼마나 되어야하는지를 결정.
2. Paint 단계: 계산한 위치/크기(레이아웃)를 기반으로 화면에 그린다. 
    - 시각적(색상, 이미지, 텍스트등)을 픽셀로 변환하여 화면에 렌더링.

## 요청과 응답

**브라우저의 핵심 기능**

필요한 리소스를 서버에 요청 ⇒ 서버에서 응답받아 브라우저에 시각적을 렌더링(파싱하여 렌더링)

서버에 요청을 전송하기 위해 브라우저는 주소창을 제공함. 

브라우저에 url 입력 ⇒ url 의 호스트 이름이 dns를 통해 ip주소로 변환되고 이 ip주소를 갖는 서버에게 요청을 전송함 

예) http<hi>s://poiemaweb.com (http<hi>s://poiemaweb.com검색) (/.스킴과 호스트만으로 구성된 URI) 입력⇒poiemaweb서버로 
요청전송 ⇒ 루트 요청에 명확한 리소스를 요청하는 내용x 하지만 서버는 루트 요청에 대해 암묵적으로 index.html을 응답하도록 기본 설정되어있음.

즉, 
http<hi>s://poiemaweb.com = https:poiemaweb.com/index.html 같은요청

루트 요청에 대해 서버의 루트 폴더에 존재하는 정적 파일 index.html을 클라이언트(브라우저)로 응답. 만약 타 정적 파일 요청 원함 
http<hi>s://poiemaweb.com/assets/data/data.json과 같이 서버의 루트 폴더를 기준으로 요청할 정적 파일의 경로와 파일이름을 URI의 host(domain)뒤의 path에 써서 요청. 

⇒ 서버 루트 폴더의 assets/data폴더 내에 있는 data.json응답. 

브라우저의 주솣창을 통해 서버에게 정적 파일요청

자바스크립트를 통해 동적으로 서버에 정적/동적 파일 요청 

ajax REST API 

요청과 응답⇒ 크롬 개발자도구 Network패널에서 확인 가능. (패널 활성화하기 전에 이미 응답받았으면 표시되지않음⇒ 새로고침)

html리소스 URI요청⇒ 기본 index.html뿐만아니라 CSS,자바스크립트 이미지 폰트파일들도 응답됨

왜? 브라우저의 렌더링 엔진이 HTML 을 파싱하는 도중에 외부 리소스를 로드하는 태그를 만나면 HTML 파싱을 일시 중단하고 해당 리소스 파일을 서버로 요청하기 때문. 

예) 

- CSS파일을 로드하는 link태그
- 이미지 파일을 로드하는 img태그
- 자바스크립트를 로드하는 script태그

### HTTP 1.1 vs HTTP 2.0

HTTP/1.1(1999) ⇒ 커낵션당 하나의 요청과 응답만 처리 
HTML 문서 내에 포함된 여러개의 리소스 요청이 개별적으로 전송되고 응답도 개별적으로 전송 

동시 전송이 불가, 리소스의 개수에 비례하여 응답 시간도 증가함

HTTP2.0 ⇒ 커낵션과 여러개의 요청과 응답 가능=다중 요청/응답 가능 
속도가 50%빠름

### HTML 파싱과 DOM생성

브라우저의 요청에 의해 서버가 응답한 HTML 문서: 문자열로 이루어진 순수한 텍스트 

이를 브라우저에 시각적인 픽셀로 렌더링하고싶으면 HTML문서를 브라우저가 이해할 수 있는 자료구조(객체)로 변환하여 메모리에 저장해야 함 

1. 서버에 존재하던 HTML 파일이 브라우저의 요청에 의해 응답됨.이때 서버: 브라우저가 요청한 HTML파일을 읽어들여 메모리에 저장함 ⇒ 메모리에 저장된 바이트(2진수)를 인터넷을 경유하여 응답함 
2. 브라우저: 서버가 응답한 HTML문서를 바이트 형태로 응답받음
meta태그의 charset 어트리뷰트에 의해 지정된 인코딩방식을 기준으로 문자열로 변환됨.(예)UTF-8) 
응답헤더에 담겨 응답되는데,(예)content-type: text-html/charset=utf-9) ⇒이를 확인 ⇒ 문자열로 변환

3.문자열로 반환된 html문서를 일어들임⇒ 문법적의미를 갖는 코드의 최소 단위인 token으로 분해 

1. 각 토큰들을 객체로 변환하여 노드들을 생성 
예) 문서노드, 요소노드, 어트리뷰트노드, 텍스트 노드 
노드는 이후 DOM을 구성하는 기본 요소가 됨.
2. HTML 문서 = HTML 요소들의 집합으로 이루어짐. 
    - HTML 요소는 중첩관계를 가짐 HTML 요소의 콘텐츠 영역(시작태그와 종료태그의 사이) 에는 텍스트 뿐만 아니라 다른 HTML요소도 포함 될 수 있음.
        
        ⇒ HTML 요소간의 중첩관계에 의해 부자관계가 형성. ⇒ 부자 관계를 반영하여 모든 노드들을 트리 자료구조로 구성. 
        
        이 트리 자료구조 = DOM
        

 DOM: HTML 문서를 파싱한 결과물. 

### CSS파싱과 CSSOM 생성

렌더링 엔진: HTML을 처음부터 한 줄씩 순차적으로 파싱하여 DOM을 생성⇒ 생성하다가 CSS를 로드하는 link태그나 style 태그를 만나면 DOM생성 일시중지

link태그의 href어트리뷰트에 지정된 CSS파일을 서버에 요청하여 로드한 CSS파일이나 style태그 내의 CSS를 HTML 과 동일한 파싱과정을 거치며 해석하여 CSSOM을 생성함 

바이트 ⇒ 문자 ⇒ 토큰 ⇒ 노드 ⇒ CSSOM (CSS의 상속을 반영하여 생성됨)

⇒ CSS 파싱 완료 ⇒ HTML 파싱이 중단된 지점부터 다시 HTML 파싱 시작 ⇒ DOM 생성 재개 

### 렌더 트리 생성

서버로부터 응답된 HTML과 CSS ⇒ 렌더링엔진이 파싱⇒ DOM과 CSSOM생성 ⇒ **DOM과 CSSOM은 렌더링을 위해 렌더트리(트리구조의 자료구조)로 결합됨**

- 브라우저 화면에 렌더링되는 노드만으로 구성됨.

⇒ 완성된 렌더트리는 각 HTML요소의 레이아웃(위치와 크기)를 계산하는데 사용됨⇒ 페인팅 처리(브라우저 화면에 픽셀을 렌더링)에 입력됨 

반복해서 리렌더링될 수 있음. 다음과 같은 과정의 경우 레이아웃 계산과 페인팅이 재차 실행됨: 

- 자바스크립트에 의한 노드 추가 또는 삭제
- 브라우저 창의 리사이징에 의한 뷰포트 크기 변경
- HTML 요소의 크기에 변경을 발생시키는 width/height margin, padding…등의 스타일 변경

리렌더링: 비용이 많이 듬 많이 일어나지않도록 주의.

**파싱(구문 분석 parsing/syntax Analysis)** 

하나의 프로그램을 런타임 환경(예) 브라우저 내의 자바스크립트 엔진)이 실제로 실행 가능한 내부 포맷으로 분석하고 변환하는 것을 의미

텍스트 문서의 문자열을 토큰으로 분해(어휘분석) 토크나이징⇒ 토큰에 문법적 의미와 구조를 반영하여 (토큰들의 집합을 구문분석) AST(추상적 구문 트리)를 생성하는 과정. 

일반적으로 파싱이 완료되면 AST를기반으로 중간언어인 바이트코드를 생성하고, 인터프리터에 의해 실행된다. 

[https://yceffort.kr/2021/05/ast-for-javascript](https://yceffort.kr/2021/05/ast-for-javascript)

**렌더링** 

HTML, CSS, 자바스크립트로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것 

**렌더링엔진** 

브라우저는 브라우저마다 렌더링을 수행하는 렌더링 엔진이 있다. 예) 크롬은 블링크(Blink), 사파리는 웹킷(Webkit), 파이어폭스는 게코(Gecko).

**CRP (Critical Rendering Path, 중요 렌더링 경로)**

브라우저가 HTML,CSS,Javascript를 화면에 픽셀로 변화시키는 일련의 단계를 말함. Document Object Model(DOM),  CSS Object Model(CSSOM), 렌더 트리, 그리고 레이아웃을 포함한다.

**DOM (Document Object Model)**

웹 페이지를 이루는 태그들을 자바스크립트가 이용할 수 있게끔 브라우저가 트리구조로 만든 모델을 의미. 문서 객체모델. 문서 객체란 hteml, head,body와 같은 태그들을 javascript가 이용(메모리에 보관)할 수 있는 객체를 의미. HTML과 스크립팅언어(자바스크립트등)를 서로 이어주는 역할. 

[https://developer.mozilla.org/ko/docs/Web/API/Document_Object_Model/Introduction](https://developer.mozilla.org/ko/docs/Web/API/Document_Object_Model/Introduction)

**CSSOM (CSS Object Model)** 

CSS내용을 파싱하여 자료를 구조화 한 것. DOM처럼 CSS의 내용을 해석하고 노드를 만들어 트리 구조로 만든 것을 CSSOM이라고 함. 

**렌더트리 (Render Tree)**

CSSOM+ DOM 트리의 결합으로 만들어짐. 웹 페이지에 나타낼 각 요소들의 위치(레이아웃)을 계산하는데 사용됨. 픽셀을 화면에 렌더링하는 페인트(Paint), 즉 화면에 요소들을 표현하는 프로세스를 위해 존재.

**Layout(Reflow)**

뷰포트 내에서 노드의 정확한 위치와 크기를 계산하는것을 Layout단계 또는 Reflow라고함. 

**Paint** 

브라우저 엔진이 노드와 해당 노드의 계산된 스타일 및 기하학적 형태에 대해 파악함⇒ 렌더링 트리의 각 노드를 화면의 실제 픽셀로 변환하는 마지막 단계에 이러한 정보를 전달하는 과정.

페인팅 또는 레스터화라고 함.  
 

### 리플로우와 리페인트

자바스크립트 코드에 DOM이나 CSSOM을 변경하는 DOM API가 사용된 경우⇒ DOM이나 CSSOM이 변경됨 ⇒ 변경된 DOM, CSSOM은 다시 렌더 트리로 결합됨⇒ 레이아웃⇒ 페인트  ⇒ 다시렌더링 (리플로우, 리페인트)

노드 추가/삭제, 요소의 크기/위치변경 윈도우 리사이징등의 레이아웃에 영향을 주는 변경이 발생한 경우에 한하여 실행됨. 

순차적으로 동시에 실행x 레이아웃에 영향이 없는 변경은 리플로우없이 리페인트만 실행됨. 

###
