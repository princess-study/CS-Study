## 4.1  변수란?

변수: 컴퓨터가 연산해서 만들어낸 값은 재사용할 수 없는데 만약 재사용하려고 한다면 연산 결과가 저장된 메모리 공간에 직접 접근하는 것 외에는 방법이 없다 하지만 직접 메모리 주소에 접근하는 것은 치명적 오류를 발생시킬 가능성이 높고 위험하다. 그래서 변수가 존재한다. 데이터를 저장할 때 쓰이는 ‘이름이 붙은 저장소’ : const, let, var

변수: 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름 , 값의 위치를 가리키는 상징적인 이름

- 식별자: 변수 이름 , 값이 아니라 메모리 주소를 기억하고 있다.

## 4.2 식별자

식별자: 변수 이름, 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름

### 최근 let 예전 var 차이

- 동일하게 동작, 단 var 는 ‘오래된 방식’

### 최신 자바스크립트에서는 let과 const를 사용하니 몰라도 되는거 아닌가요?

- 오래된 var
    
    var로 선언한 변수는 let으로 선언한 변수와 유사하지만 예전 자바스크립트라 최신 자바스크립트에서 사용하는 let 과 const 와는 구현 방식이 다름
    
    ## 최신 자바스크립트에서는 let과 const를 사용하니 몰라도 되는거 아닌가요?
    
    - var를 사용하는 오래된 스크립트를 let으로 바꿀 때 var에 대해 제대로 모른다면 예상치 못한 에러를 만날 수 있음
    
    ### 1. var는 블록 스코프가 없다.
    
    - var로 선언된 변수의 스코프는 함수 스코프이거나 전역 스코프입니다. 블록 기준으로 스코프가 생기지 않기 때문에 블록 밖에서 접근 가능
    
    ```jsx
    if (true) {
      var test = true; // 'let' 대신 'var'를 사용했습니다.
    }
    
    alert(test); // true(if 문이 끝났어도 변수에 여전히 접근할 수 있음)
    ```
    
    var는 코드 블록을 무시함 ⇒ 전역 스코프에서 접근 가능
    
    ## 스코프란?
    
    함수가 실행될 때, 함수 내에서 변수에 대한 접근이 어떻게 되는지를 의미함 - 스코프는 함수를 기준으로 한다.
    
    ## 컨텍스트
    
    this 키워드 값이 무엇인지 나타내는 용어. (현재 실행 컨텍스트 내에서 어떤 객체를 참조하고 있는지를 의미) - 객체를 기반으로 함
    
    ## 함수 스코프
    
    - 자바스크립트는 기본적으로 함수 스코프를 따름 → 함수 내에서 선언한 변수는 해당 함수 안에서만 접근 가능하다.
    - 함수 스코프 = 지역 스코프
    
    ```jsx
    if(5 > 4) {
    	var secret = '12345';
    }
    secret // '12345'
    ```
    
    위 코드는 함수가 선언되어 있지 않음 → 새로운 스코프가 형성되지 않음 → 동일한 실행 컨텍스트 내에 존재함을 의미 → 어디서나 secret변수에 접근 가능
    
    ## 블록 스코프
    
    - {} 이 생성될 때마다 새로운 스코프가 형성되는 것을 의미
    - 원래 자바스크립트는 함수 스코프를 따르지만, let과 const 등장으로 블록 스코프 형성 가능해짐

## 4.3 변수 선언과 할당

이 과정은 세가지 단계로 나뉜다. 

1. 선언
2. 초기화
3. 할당

### 실행 컨텍스트

- 실행할 코드에 제공할 환경 정보들을 모아놓은 객체

[https://junilhwang.github.io/TIL/Javascript/Domain/Execution-Context/#_2-실행-컨텍스트-구성](https://junilhwang.github.io/TIL/Javascript/Domain/Execution-Context/#_2-%E1%84%89%E1%85%B5%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC-%E1%84%8F%E1%85%A5%E1%86%AB%E1%84%90%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3-%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC)

## 4.3.1 선언

선언: 변수를 생성하는 것 (var, let ,const)

```jsx
let geonwoo;
const princess;
```

자바스크립트 엔진의 변수 선언

1. 선언 단계: 코드 실행전 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
2. 초기화 단계 값을 저장하기 위한 메모리의 공간을 확보하고 암묵적으로 undefined를 할당해 초기화

### 4.3.2 초기화

선언 키워드를 통해 이름이 정해진 변수에 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당하여 초기화

### var

1. 실행 컨텍스트 Execution phase(실행 단계)에서 실행 컨텍스트에 변수를 등록한다.
2. 콜 스택의 메모리 저장 공간에 해당 변수를 위한 메모리 공간을 확보한다.
3. 그 공간의 주소 값을 실행 컨텍스트에 등록된 변수에 저장한다.
4. 해당 저장 공간에 `undefined`를 할당하는 것으로 초기화를 진행한다.

- **`var` 키워드의 경우 선언과 초기화가 함께 일어남** , 메모리를 갖고 있는 변수로 간주되어 **선언문 앞에서도 해당 변수는 참조가 가능하게 된다**.
- 참조가 가능해진 `var`로 선언한 변수는 **실행 컨텍스트 최상위로 이동**하게 되고,

`var` 키워드로 선언한 변수가 호이스팅이 일어나는 과정이라고 볼 수 있다.

### const, let

**실행 컨텍스트 Execution phase(실행 단계)에서 실행 컨텍스트에 변수를 등록하는 선언 단계를 거치고 난 후 해당 과정에서는 아무런 작업이 일어나지 않는다.**이 둘의 초기화 단계는 런 타임 과정에서 발생한다.

```
let byeonSu = 10; // 실제 코드

// 실제 코드를 런타임 과정 시점으로 살펴본다면,
let byeonSu // 초기화 (1)
byeonSu = 10; // 할당 (2)
```

해당 코드를 통해 대충 알 수 있듯, `let`, `const` 의 초기화 단계는 **런 타임 과정**에서 이루어진다.

먼저 초기화 부분 (1) 런타임에서 발견하면,

1. 콜 스택 메모리 저장 영역에 해당 변수를 위한 메모리를 확보하여 undefined를 할당한다.
2. 해당 메모리 주소값을 변수에 저장한다.

## 4.3.3. 값의 할당

- 변수의 선언과 값의 할당을 하나의 문장으로 단축 표현해도 자바스크립트 엔진은 변수의 선언과 값의 할당을 2개의 문으로 나누어 각각 실행한다.
    
    ```jsx
    var geonwoo = 80;
    ```
    
    1. 먼저 선언시 변수에 undefined가 할당되어 초기화됨
    2. 값을 할당할때 undefined가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값 80을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 할당 값 80을 저장함

다시 정리하자면,

`var` : **실행 컨텍스트 Execution phase(실행 단계)**에서 선언과 초기화 단계가 이루어지고, **런 타임 과정**에서 할당이 이루어진다.

`let`, `const` : **실행 컨텍스트 Execution phase(실행 단계)**에서 **선언 단계**만 이루어지고, **런 타임 과정**에서 **초기화 단계** 후 새로운 메모리를 확보하여 할당할 값을 저장한다.

그리고 초기화 단계에서 **`undefined`가 저장 되어있는 주소값**을 **할당값이 저장된 주소값**으로 교체하여 **할당 단계**가 이루어진다.

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

### 문제 상황

> 변수 선언문이 코드의 선두로 끌어 올려진 것 처럼 동작하는 자바스크립트 고유의 특징
> 

!https://velog.velcdn.com/images/pigpgw/post/3dfd385b-1de1-4ddc-826f-ec20eef90db9/image.png

위 코드의 결과가 뭘까 당연히 선언 이전에 참조를 먼저 했으니 당연히 참조 에러가 날 줄 알았다. 하지만

!https://velog.velcdn.com/images/pigpgw/post/a631cfab-d72b-4e58-a9f0-b534b22bbef4/image.png

위처럼 undefined가 나온다. 이 이유를 찾아보니 변수 호이스팅이라는 것이었다.

### 변수 호이스팅이 뭔데?

> 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.
> 

라고 나와있었다. 이게 무슨소리냐

### 변수가 선언되는 시점

자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 소스코드의 평가 과정을 거쳐서 소스코드를 실행하기 위한 준비를 한다. (실행 컨텍스트 개념 이해가 필요하니 추후에 자세하게 다룰 예정)

> 즉 ! 자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관 없이 다른 코드보다 먼저 실행하기에 변수 선언이 소스코드의 어디에 위치하는지와 상관없이 어디서드니 변수를 참조할 수 있다.
> 

### 자바스크립트의 변수 생성 단계

1. 선언(Declaration): 스코프와 변수 객체가 생성되고, 스코프가 변수 객체를 참조한다. 초기화 전까지는 TDZ 상태이다.
2. 초기화(Initialization): 변수 객체 값을 위한 공간을 메모리에 할당한다.
3. 할당(Assignment): 변수 객체에 값을 할당한다.

### var, let, const

var는 선언과 동시에 초기화가 이루어진다. 즉, 선언과 동시에 undefined가 할당된다.

```jsx
console.log(hoistedVar); // undefined
var hoistedVar = 'I am hoisted!';
console.log(hoistedVar); // Output: 'I am hoisted!'
```

위 코드는 실제로 아래와 같이 동작합니다.

```jsx
var hoistedVar;
console.log(hoistedVar); // undefined
hoistedVar = 'I am hoisted!';
console.log(hoistedVar); // Output: 'I am hoisted!'
```

그러나 let과 const는 다르다. 선언만 될뿐, 초기화가 이루어지지 않는 메모리 할당이 아직 되지 않은 TDZ에 들어가게 된다.(TDZ는 다음에 다루기로)

모든 선언(function, var, let, const 및 class)은 JavaScript에서 호이스팅되며, var 선언은 undefined로 초기화되지만 let 및 const 선언은 초기화되지 않은 상태로 유지된다.

> 결론: 변수 선언문이 코드의 선두로 올려진 것처럼 동작하는 자바스크립트 고유의 특징을(var만 해당) 변수 호이스팅이라 한다.
> 

## 4.5 값의 할당

변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.

```jsx
console.log(hoistedVar); // undefined
var hoistedVar = 'I am hoisted!'; // 변수 선언과 값의 할당 
console.log(hoistedVar); // Output: 'I am hoisted!'
```

- undefined가 저장되어 있던 메모리 공간을 지우고 그 메모리에 할당 값을 저장하는게 아니라 새로운 메모리 공간을 확보하고 할당 값 80을 저장함

## 4.6 재할당

재할당: 변수에 저장된 값을 다른 값으로 변경

상수: 변수에 저장된 값을 변경할 수 없음 - const(하지만 반드시 상수만을 위해 사용되지는 않음)

재할당시 이전 값이 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 재 할당 하는것이 아닌 새로운 메모리 공간을 확보하고 그 메모리 공간에 숫자 90을 저장

const로 선언된 변수는 선언과 초기화가 함께 이루어져야 하며, 초기화된 후에는 값을 변경할 수 없습니다.

```jsx
const pi = 3.14;
// pi = 3.1415; // Error: 상수를 재할당할 수 없습니다.
console.log(pi); // Output: 3.14
```

## 4.7 식별자 네이밍 규칙

- 변수나 함수 : 카멜 케이스 ( ex: firstName)
- 생성자 함수, 클래스 이름: 파스칼 케리스 (ex: FirstName) (생성자 함수: 객체를 생성하기 위한 함수)

리터럴: 사람이 이해할 수 있는 문자 또는 미리 약속된 기호로 표기한 코드

참조

- 모던 자바스크립트 딥 다이브
- https://ko.javascript.info/var
- [자바스크립트의 스코프 : 함수 스코프와 블록 스코프](https://soldonii.tistory.com/63)
- [스코프(Scope)란?](https://medium.com/@yeon22/javascript-%EC%8A%A4%EC%BD%94%ED%94%84-scope-%EB%9E%80-bc761cba1023)